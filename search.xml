<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>看球日记1：双红会</title>
      <link href="/2024/04/08/kq/"/>
      <url>/2024/04/08/kq/</url>
      
        <content type="html"><![CDATA[<h1 id="看球日记1：双红会-2024-04-08"><a href="#看球日记1：双红会-2024-04-08" class="headerlink" title="看球日记1：双红会 2024 04 08"></a>看球日记1：双红会 2024 04 08</h1><p>（写在前面：本来想给f1日本站也写一个观赛记录的，但是实在是太无聊了！！等什么时候潘子不拿冠军了我再写）  </p><p>这场双红会，比分2：2，曼联球迷对过程不满意，利物浦球迷对结果不满意。<br>赛前我舍友问我对结果预测如何，我直接以我二十年曼联球迷的直觉预测说曼联不可能赢；跟某资深利物浦球迷聊天，他指出了这场比赛对于利物浦的重要性，也就是说不赢不行。我对曼联一开始的期望是苟住平局，看完伤兵名单和首发阵容以后我仔细一想，就这套阵容，守也守不住，不如跟利物浦爆了。<br>上半场果然在我的预想之中，除了一开场加纳乔那个越位球给我兴奋了一下之外，整个上半场利物浦都是按着曼联揍，曼联上半场0射门也说明了很大的问题，要不是萨拉赫和奥纳纳，上半场估计就花了。<br>但正当我以为大局已定准备上床睡觉的时候，让我万万没想到的事情发生了，利物浦的小将后卫失误送了b费一个几乎是吊射空门的机会，曼联就借着这个球1：1扳平了比分。<br>看到这我就精神了，一下子从床上弹起来接着看直播，然后发现曼联果然起势了，可以说没有夸安萨这一波失误，曼联这场可能真就玩完了。<br>然后就是科比梅努了，一招后仰射门直接打进上角，利物浦的浪费机会以及似乎能看出来的轻敌（存疑）最终使他们付出了代价，在这么多运动战射门的情况下，最终却还要靠定位球和点球与曼联堪堪打平，这绝对不是他们值得骄傲的事情。<br>最后简评下曼联这边，表现总体来说是都可以接受的，奥纳纳梅努坎布瓦拉自然不用多说，两个边后卫虽然都有失误，但总体上万比萨卡功过相抵，达洛特功大于过；拉什福德这场能看出来有点拼，至少比前几场纯在摆烂强；霍伊伦中规中矩；b费我上半场一直在骂，但那个进球很关键，可以抹去他的大部分抽象；卡塞米罗老了，但是尚能一战；加纳乔够拼；替补那几位除了阿姆拉巴特也都不错了，总体上看曼联这场的表现问题没那么大，而且曼联也并没有龟缩而是出来压迫，虽然中场又跟个大马路一样，但至少体现出来了腾哈格“勇猛”的一面。<br>这赛季的曼联抽象到一定程度了，无论是远的去年欧冠，还是近的上场踢切尔西，都让我不忍直视，但好处是曼联打硬仗的那股劲一直没丢，这依旧是值得鼓励的。但作为球迷，我能做的恐怕只有继续等待曼联的复兴了……<br>Eddie 2024.04.08 15:00 pm</p>]]></content>
      
      
      
        <tags>
            
            <tag> 看球 </tag>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Appendix C</title>
      <link href="/2023/12/03/review-appendix-c-cd9a0ed5b3cf4315b26d30684db02354/"/>
      <url>/2023/12/03/review-appendix-c-cd9a0ed5b3cf4315b26d30684db02354/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Appendix-C"><a href="#Review-Appendix-C" class="headerlink" title="Review Appendix C"></a>Review Appendix C</h1><p>都说Appendix A和C是全书精华之精华，那还是要把Appendix C消化消化的，争取正式开学之前看完它。</p><p>Two main component of a microachitecture: the data path, which contains all the components that actually process the instructions, and the control, which contains all the components that generate the set of control signals that are needed to control processing at each clock cycle.</p><p><img src="/Review%20Appendix%20C%20cd9a0ed5b3cf4315b26d30684db02354/Untitled.png" alt="Untitled"></p><p><img src="/Review%20Appendix%20C%20cd9a0ed5b3cf4315b26d30684db02354/Untitled%201.png" alt="Untitled"></p><p><img src="/Review%20Appendix%20C%20cd9a0ed5b3cf4315b26d30684db02354/Untitled%202.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 1</title>
      <link href="/2023/12/02/ics-2023-review-chap-1-2f9e9fc7a6224dbcb7db7a95853e3bcf/"/>
      <url>/2023/12/02/ics-2023-review-chap-1-2f9e9fc7a6224dbcb7db7a95853e3bcf/</url>
      
        <content type="html"><![CDATA[<h1 id="ICS-2023-Review-Chap-1"><a href="#ICS-2023-Review-Chap-1" class="headerlink" title="ICS 2023 Review Chap 1"></a>ICS 2023 Review Chap 1</h1><ul><li>1.abstraction: a technique for establishing a simpler way for a person to interact with a system, removing the details that are unnecessary for the person to interact effectively with the system. We all need the ability to abstract. Hardware and software: we need to know both of them, instead of seperating them.</li><li>A computer system generally includes, in addition to the processor, a keyboard for typing commands, a mouse or keypad or joystick for positioning on menu entries, a monitor for displaying information that the computer system has produced, memory for temporarily storingv information, disks and USB memory sticks of one sort or another forstoring information for a very long time, even after the computer has been turned oﬀ,connections to other devices such as a printer<br> for obtaining paper copies of that information, and the collection of programs(the software) that the user wishes to execute.</li><li>Two important ideas:（1）All computers are capable of computing exactly the same things if they are given enough time and enough memory. The only difference is the time.(2) (in Chinese) 计算机无法直接领悟自然语言，所以我们需要用一种计算机能够执行的语言去指导计算机解决问题。</li><li>Before modern digital computers, the most common digital machines in the West were <em>adding machines</em> that can add integers. In other parts of the world another digital machine, the abacus, was common. The main limitation of all these machines is that they could do only one specific kind of computation.</li><li>This is why computers are different. You can tell a computer how to add numbers. You can tell it how to multiply. You can tell it how to alphabetize a list or perform any computation you like. When you think of a new kind of computation, you do not have to buy or design a new computer. You just give the old computer <strong>a new set of instructions</strong> (a program) to carry out the new computation. This is why we say the computer is a <strong>universal computational device</strong>. Computer scientists believe that <em>anything that can be computed</em>, can be computed by a computer provided it has enough time and enough memory. <em>When we study computers, we study the fundamentals of all computing.</em> We learn <strong>what computation is</strong> and <strong>what can be computed</strong>.</li><li>教材在该章节之后的内容提到了<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">图灵机</a>，我不知道如何用简洁的语言提炼内涵，所以我就摘抄最核心的这么一句话：“One way to try to construct a machine more powerful than any particular Turing machine was to make a machine U that could simulate all Turing machines.”</li></ul><p><img src="/ICS%202023%20Review%20Chap%201%202f9e9fc7a6224dbcb7db7a95853e3bcf/Untitled.png" alt="Untitled"></p><aside>💡 注：伪代码属于problems</aside><ul><li><p>Problems: described in natural language(e.g. English or Chinese), which are unacceptble for computers. One reason is the ambiguity.</p></li><li><p>Algorithms: We first need to transform the natural language description of a problem to algorithm. Here are the properties of the algorithm:</p></li><li><p>(1) <em>definiteness</em>. Each step is precisely stated. In Chinese we say 确定性, 即每一步都是确定的，无歧义的。</p></li><li><p>(2) <em>effective computability</em>. Each step can be carried out by a computer. 可算性，每一步都能被电脑操作运行。</p></li><li><p>(3) <em>finiteness</em>. 有限性， 也就是说算法是可以也终将会被中止的。</p></li><li><p>Program: there are programming languages like C or C++. In fact there are more than 1,000 programming languages. We need to transform the algorithm into a  computer program using one of them. There are high-level and low-level languages. One representative low-level language is <em>assembly language</em>.</p><p>  <img src="/ICS%202023%20Review%20Chap%201%202f9e9fc7a6224dbcb7db7a95853e3bcf/Untitled%201.png" alt="Untitled"></p></li><li><p>ISA: it is the complete specification of the interface between programs that have been written and the underlying computer hardware that must carry out the work of those programs.</p></li><li><p>Sequence of 0s and 1s(the length is 16 in LC-3), which specifies the acceptable representations for operands and the mechanisms that the computer can use to figure out where the operands are located.</p></li><li><p>The number of opcodes,data types,and addressing modes specified by an ISA vary among different ISAs.</p></li><li><p>Microarchitecture (or <strong>implementation</strong>) is the <strong>digital logic</strong> that allows an instruction set to be executed. A microarchitecture is the <strong>physical implementation</strong> of an instruction set.</p></li><li><p>Each microarchitecture is an opportunity for computer designers to make different <strong>tradeoffs</strong> between the cost of the microprocessor, the performance that microprocessor will provide, and the energy that is required to power the microprocessor.</p></li></ul><p>(From 修佬）微架构和上面提到的指令集有点像“现实与虚拟”交界处的两个守门人。对于 ISA 来说，微架构是它的电路实现，你可以有不同的电路，拿一个指令对应什么事情，这些是不能改变的，所以说 ISA 可以对应多个微架构，但是一个微架构只能对应一个 ISA。</p><ul><li>Logic Circuit: let’s talk about it in chapter 3.</li><li>Devices</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Other Things You Need to Know to Pass the Exam</title>
      <link href="/2023/12/01/other-things-you-need-to-know-to-pass-the-exam-5d8b87e58f4949f4a863c2517980f023/"/>
      <url>/2023/12/01/other-things-you-need-to-know-to-pass-the-exam-5d8b87e58f4949f4a863c2517980f023/</url>
      
        <content type="html"><![CDATA[<h1 id="Other-Things-You-Need-to-Know-to-Pass-the-Exam"><a href="#Other-Things-You-Need-to-Know-to-Pass-the-Exam" class="headerlink" title="Other Things You Need to Know to Pass the Exam"></a>Other Things You Need to Know to Pass the Exam</h1><p>Control Unit and Processing Unit 合称CPU</p><p>CC：condition code也就是状态码</p><p><code>TRAP</code>：中文是<strong>自陷</strong>或<strong>软中断</strong>，其本质为用户程序向OS申请帮助。</p><p><img src="/Other%20Things%20You%20Need%20to%20Know%20to%20Pass%20the%20Exam%205d8b87e58f4949f4a863c2517980f023/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 9</title>
      <link href="/2023/11/28/review-chap-9-4e7fd7f41df64af38e6bea1c5827e4ec/"/>
      <url>/2023/11/28/review-chap-9-4e7fd7f41df64af38e6bea1c5827e4ec/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-9"><a href="#Review-Chap-9" class="headerlink" title="Review Chap 9"></a>Review Chap 9</h1><h3 id="Privilege-Priority-and-the-Memory-Address-Space"><a href="#Privilege-Priority-and-the-Memory-Address-Space" class="headerlink" title="Privilege,Priority, and the Memory Address Space"></a>Privilege,Priority, and the Memory Address Space</h3><p><strong>Privilege</strong>: it is about the right to do something, such as execute a particular instruction or access a particular memory location.(<strong>NOTE:</strong> not all computer programs have the right to execute all instructions.)</p><p>To make the system go correctly, we designate every computer system as either privileged or unprivileged. We often say supervisor privilege to indicate privileged. We say a program is executing in <strong>Supervisor</strong> mode to indicate <strong>privileged</strong>, or <strong>User</strong> mode to indicate <strong>unprivileged</strong>.</p><ul><li>If a program is executing in Supervisor mode, it can execute all instructions and access all of memory.</li><li>If a program is executing in User mode, it cannot.</li></ul><p><strong>Priority</strong>: it is about the urgency of a program to execute. This allows programs of greater urgency to interrupt programs of lesser urgency.</p><p><strong>Two Orthogonal Notions</strong></p><p>We said privilege and priority are two orthogonal notions, meaning they have nothing to do with each other.</p><p><strong>The Processor Status Register</strong></p><p>It contains the privilege and priority assigned to that program.</p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled.png" alt="Untitled"></p><p>Bit 15 specifies the privilege, where <strong>PSR[15]&#x3D;0 means supervisor privilege, and PSR[15]&#x3D;1 means unprivileged</strong>. Bits[10:8] specify the priority level of the program. The highest level is 7 and the lowest level is 0. Besides, it also contains the condition code.</p><p><strong>Organization of Memory</strong></p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%201.png" alt="Untitled"></p><ul><li>Locations x0000 to x2FFF are privileged memory locations. They contain the various data structures and code of the operating system. They require supervisor privilege to access. They are referred to as <strong>system space</strong>.</li><li><strong>Supervisor Stack</strong> is controlled by the operating system and requires <strong>supervisor</strong> privilege to access. It has a stack pointer called <strong>SSP</strong> (Supervisor Stack Pointer).</li><li>Locations x3000 to xFDFF are unprivileged memory locations. Supervisor privilege is not required to access these memory locations. All user programs and data use this region of memory. The region is often referred to as <strong>user space</strong>.</li><li><strong>User Stack</strong> is controlled by the user program and does <strong>not require privilege</strong> to access. It has a stack pointer called <strong>USP</strong> (User Stack Pointer).</li><li>Addresses xFE00 to xFFFF do not correspond to memory locations at all. That is, the last address of a memory location is xFDFF. Addresses xFE00 to xFFFF are used to identify registers that take part in input and output functions and some special registers associated with the processor.</li><li>PSR ~ xFFFC</li><li>processor’s <strong>M</strong>aster <strong>C</strong>ontrol <strong>R</strong>egister (<strong>MCR</strong>)(clock cycle switch) ~ xFFFE</li><li><strong>KBSR</strong> <strong>KBDR</strong> <strong>DSR</strong> <strong>DDR</strong> …</li><li>这些并不是实际内存，而是别映射过来的 <strong>Memory-mapped I&#x2F;O</strong> ！</li><li>Since a program can only execute in <strong>Supervisor</strong> mode or <strong>User</strong> mode at any one time, only <strong>one</strong> of the two stacks is active at any one time.</li><li><strong>R6</strong> is generally used as the <strong>SP</strong> for the active stack. Two registers, <strong>Saved_SSP</strong> and <strong>Saved_USP</strong>, are provided to save the <strong>SP</strong> not in use. When privilege changes, for example, from <strong>Supervisor</strong> mode to <strong>User</strong> mode, the <strong>SP</strong> is stored in <strong>Saved_SSP</strong>, and the <strong>SP</strong> is loaded from <strong>Saved_USP</strong>.</li></ul><h3 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input&#x2F;Output"></a><strong>Input</strong>&#x2F;<strong>Output</strong></h3><ul><li>Even the simplest I&#x2F;O devices usually need at least <strong>two</strong> registers: one to hold the <strong>data</strong> being transferred between the device and the computer, and one to indicate <strong>status information</strong> about the device.</li><li>An example of status information is whether the device is <strong>available</strong> or is it still <strong>busy</strong> processing the most recent I&#x2F;O task.</li><li>Some Basic <strong>Characteristics</strong> of I&#x2F;O</li></ul><p><strong>Memory-Mapped I&#x2F;O</strong> vs. <strong>Special I&#x2F;O Instructions</strong></p><ul><li>The I&#x2F;O device registers are mapped to a set of addresses that are allocated to I&#x2F;O device registers rather than to memory locations. Hence the name <strong>memory-mapped I&#x2F;O</strong>.</li><li>Special I&#x2F;O Instructions are not so liked.</li></ul><p><strong>Asynchronous</strong> vs. <strong>Synchronous</strong></p><ul><li>Most I&#x2F;O is carried out at speeds very much <strong>slower</strong> than the speed of the processor.</li><li>The point is that I&#x2F;O devices usually operate at speeds very different from that of a microprocessor, and not in lockstep. We call this latter characteristic <strong>asynchronous</strong>. Most interaction between a processor and I&#x2F;O is asynchronous.</li><li>To control processing in an asynchronous world requires some <strong>protocol</strong> or <strong>handshaking mechanism</strong>. So it is with our keyboard and monitor.</li><li>In the case of the keyboard, we will need a one-bit status register, called a <strong>flag</strong>, to indicate if someone has or has not typed a character.</li><li>In the case of the monitor, we will need a one-bit status <strong>register</strong> to indicate whether or not the most recent character sent to the monitor has been displayed, and so the monitor can be given another character to display.</li><li>These flags are the simplest form of <strong>synchronization</strong>.</li><li>By examining the <strong>ready bit</strong> before reading a character, the computer can tell whether it has already read the last character typed.</li></ul><p><strong>Interrupt-Driven</strong> vs. <strong>Polling</strong></p><ul><li><a href="https://www.javatpoint.com/trap-vs-interrupt-in-operating-system">🔗</a> Difference between an interrupt and a trap.</li><li>The processor, which is computing, and the typist, who is typing, are two <strong>separate</strong> entities.</li><li>The issue of <strong>interrupt-driven</strong> vs. <strong>polling</strong> is the issue of who controls the interaction.</li><li><strong>Interrupt-driven</strong> acts like that the typist will tell the processor that there are some inputs.</li><li><strong>Polling</strong> acts like that the processor will interrogate typist again and again whether there have some inputs.</li><li>中断是每当监控的设备发生变化，比如有输入的时候，就执行中断相关的代码片段；而轮询是指你主动去不断请求，检测监控的设备是否发生变化。</li></ul><h3 id="Input-from-the-Keyboard"><a href="#Input-from-the-Keyboard" class="headerlink" title="Input from the Keyboard"></a>Input from the Keyboard</h3><p>Basic Input Registers (<strong>KBDR</strong> and <strong>KBSR</strong>): <strong>KBD</strong>ata<strong>R</strong> &amp; <strong>KBS</strong>tatus<strong>R</strong></p><ul><li>In the case of <strong>KBDR</strong>, bits [7:0] are used for the <strong>data</strong>, and bits [15:8] contain <strong><code>x00</code></strong>.</li><li>In the case of <strong>KBSR</strong>, bit [15] contains the synchronization mechanism, that is, the ready bit; and bit[14] is the interrupt enable bit, depending on whether or not the processor wants to give the I&#x2F;O device the right to <strong>request service</strong>.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202114753-8d54fc36-b428-4df3-9d29-c9dd39be0894.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202114753-8d54fc36-b428-4df3-9d29-c9dd39be0894.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>In LC-3, address <strong><code>xFE02</code></strong> is assigned to the <strong>KBDR</strong>; address <strong><code>xFE00</code></strong> is assigned to the <strong>KBSR</strong>.</li></ul><p>The Basic <strong>Input Service Routine</strong></p><ul><li>When type in something, <strong>KBDR</strong> is updated and <strong>KBSR</strong> is set to<code>1</code>. And <strong>KBDR</strong> can’t be changed until <strong>KBSR</strong> is reset and the data in <strong>KBDR</strong> is read. So that each character can be loaded at least one time.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1663250915942-f266facd-a29d-4782-8ae5-45eef8dec8e4.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_12,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1663250915942-f266facd-a29d-4782-8ae5-45eef8dec8e4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202521661-df28eac7-1015-4b08-94dc-f6cf5d702098.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_27,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202521661-df28eac7-1015-4b08-94dc-f6cf5d702098.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Implementation of Memory-Mapped Input</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202840874-c88d4ccf-97ac-448a-9198-b5f86ffb8c53.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_35,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202840874-c88d4ccf-97ac-448a-9198-b5f86ffb8c53.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_35%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><h3 id="Output-to-the-Monitor-In-fact-very-similar-to-the-input"><a href="#Output-to-the-Monitor-In-fact-very-similar-to-the-input" class="headerlink" title="Output to the Monitor(In fact very similar to the input)"></a>Output to the Monitor(In fact very similar to the input)</h3><p>DDR and DSR replace KBDR and KBSR.</p><ul><li>In the case of <strong>DDR</strong>, bits [7:0] are used for data, and bits [15:8] contain <strong><code>x00</code></strong>.</li><li>In the case of <strong>DSR</strong>, bit [15] contains the synchronization mechanism, that is, the ready bit.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202935420-229bae47-be40-4e58-bb94-286e192a3cfb.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202935420-229bae47-be40-4e58-bb94-286e192a3cfb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>In LC-3, address <strong><code>xFE06</code></strong> is assigned to the <strong>DDR</strong>; address <strong><code>xFE04</code></strong> is assigned to the <strong>DSR</strong>.</li></ul><p>The Basic Output Service Routine</p><ul><li>When display something, <strong>DDR</strong> is updated and <strong>DSR</strong> is cleared. And <strong>DDR</strong> can’t be changed until <strong>DSR</strong> is set to <code>1</code> and the data in <strong>DDR</strong> is printed.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203122513-1181fcb5-6e1f-4595-b41a-1a6c6b0159ff.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_32,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203122513-1181fcb5-6e1f-4595-b41a-1a6c6b0159ff.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p>Implementation of Memory-Mapped Output</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203253977-22ace587-a16b-48c9-a471-e64ff8c57ec8.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_36,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203253977-22ace587-a16b-48c9-a471-e64ff8c57ec8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%202.png" alt="Untitled"></p><h3 id="Operating-System-Service-Routines-LC-3-Trap-Routines"><a href="#Operating-System-Service-Routines-LC-3-Trap-Routines" class="headerlink" title="Operating System Service Routines (LC-3 Trap Routines)"></a>Operating System Service Routines (LC-3 Trap Routines)</h3><ul><li>In general it is ill-advised to give user programmers access to these registers. That is why the addresses of hardware registers are part of the privileged memory address space and accessible only to programs that have supervisor privilege.</li><li>The simpler solution, as well as the safer solution to the problem of user programs requiring I&#x2F;O, involves the**<code>TRAP</code>** instruction and the operating system, which of course has supervisor privilege.</li><li>It (<strong><code>TRAP</code></strong>) allows the user programmer to not have to know the gory details of I&#x2F;O discussed earlier in this chapter. In addition, it protects user programs from the consequences of other inept user programmers.</li><li>The user program uses the <strong><code>TRAP</code></strong> instruction to request the operating system to perform the task on behalf of the user program. The operating system takes control of the computer, handles the request specified by the <strong><code>TRAP</code></strong> instruction, and then returns control back to the user program at location <code>x4001</code>. As we said at the start of this chapter, we usually refer to the request made by the user program as a <strong>system call</strong> or a <strong>service call</strong>.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658290174311-dc463c14-710d-49e8-8e28-5684c506a62e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658290174311-dc463c14-710d-49e8-8e28-5684c506a62e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><strong>The Trap Mechanism</strong></p><ul><li><strong>A set of service routines</strong> executed on behalf of user programs by the operating system. These are part of the operating system and start at arbitrary addresses in system space. The LC-3 was designed so that up to 256 service routines can be specified. Table A.2 in Appendix A contains the LC-3’s current complete list of operating system service routines.</li><li><strong>A table of the starting addresses</strong> of these 256 service routines. This table is stored in memory locations x0000 to x00FF. The table is referred to by various names by various companies. One company calls this table the System Control Block. Another company calls it the Trap Vector Table. Figure 9.10 shows the Trap Vector Table of the LC-3, with specific starting addresses highlighted. Among the starting addresses are the one for the character output service routine (memory location x0420), which is stored in memory location x0021, the one for the keyboard input service routine (location x04A0), stored in location x0023, and the one for the machine halt service routine (location x0520), stored in location x0025.</li><li><strong>The <code>TRAP</code> instruction</strong>. When a user program wishes to have the operating system execute a specific service routine on behalf of the user program, and then return control to the user program, the user program uses the TRAP instruction.</li><li><strong>A linkage</strong> back to the user program. The service routine must have a mechanism for returning control to the user program.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292177168-67358cc1-7bcc-4dc1-b6ca-fee7665db839.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292177168-67358cc1-7bcc-4dc1-b6ca-fee7665db839.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><strong>The TRAP Instruction</strong></p><ul><li>The TRAP instruction causes the service routine to execute by:</li></ul><ol><li>changing the <strong><code>PC</code></strong> to the starting address of the relevant service routine on the basis of its <strong>trap vector</strong>;</li><li>providing a way to get back to the program that executed the <strong><code>TRAP</code></strong> instruction. The “way back” is referred to as a <strong>linkage</strong>;</li></ol><ul><li>As you know, the <strong><code>TRAP</code></strong> instruction is made up of two parts: the <strong><code>TRAP</code></strong> opcode 1111 and the <strong>trap vector</strong> (bits [7:0]), which identifies the service routine the user program wants the operating system to execute on its behalf. Bits [11:8] must be zero.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292696904-1ad69603-924c-41f3-a225-6a340486d062.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_24,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292696904-1ad69603-924c-41f3-a225-6a340486d062.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>The EXECUTE phase of the TRAP instruction’s instruction cycle does three things:</li></ul><ol><li>The <strong>PSR</strong> and <strong>PC</strong> are both pushed onto the system stack. Since the PC was incremented during the FETCH phase of the TRAP instruction’s instruction cycle, the <strong>return linkage</strong> is automatically saved in the <strong>PC</strong>. When control returns to the user program, the <strong>PC</strong> will automatically be pointing to the instruction following the TRAP instruction. Note that the program requesting the trap service routine can be running either in <strong>Supervisor</strong> mode or in <strong>User</strong> mode. If in User mode, R6, the stack pointer, is pointing to the user stack. Before the <strong>PSR</strong> and <strong>PC</strong> can be pushed onto the system stack, the current contents of R6 must be stored in Saved <strong>USP</strong>, and the contents of Saved <strong>SSP</strong> loaded into R6.</li><li>PSR[15] is set to 0, since the service routine is going to require supervisor privilege to execute. PSR[10:8] are left unchanged since the priority of the TRAP routine is the same as the priority of the program that requested it.</li><li>The 8-bit trap vector is zero-extended to 16 bits to form an address that corresponds to a location in the <strong>Trap Vector Table</strong>. For the trap vector x23, that address is x0023. Memory location x0023 contains x04A0, the starting address of the TRAP x23 service routine. The PC is loaded with x04A0, completing the instruction cycle.</li></ol><ul><li>The <strong><code>RTI</code></strong> Instruction: To Return Control to the Calling Program</li><li>The <strong><code>RTI</code></strong> instruction (opcode &#x3D; 1000, with no operands) pops the top two values on the system stack into the <strong>PC</strong> and <strong>PSR</strong>. Since the <strong>PC</strong> contains the address following the address of the TRAP instruction, control returns to the user program at the correct address.</li><li>Finally, once the <strong>PSR</strong> has been popped off the system stack, **<code>PSR[15]</code>**must be examined to see whether the processor was running in <strong>User</strong> mode or <strong>Supervisor</strong> mode when the TRAP instruction was executed.</li></ul><p>Trap Routines for Handling I&#x2F;O</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369283680-182086d8-2a9d-49b2-870b-f7c42c1a68d2.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_13,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369283680-182086d8-2a9d-49b2-870b-f7c42c1a68d2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369308415-c0c6ccd0-c934-44ce-85ae-be317bdca8d1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369308415-c0c6ccd0-c934-44ce-85ae-be317bdca8d1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>A Trap Routine for Halting the Computer</li></ul><h3 id="Interrupts-and-Interrupt-Driven-I-O"><a href="#Interrupts-and-Interrupt-Driven-I-O" class="headerlink" title="Interrupts and Interrupt-Driven I&#x2F;O"></a>Interrupts and Interrupt-Driven I&#x2F;O</h3><p>The essence of interrupt-driven I&#x2F;O is the notion that an I&#x2F;O device that may or may not have anything to do with the program that is running can(1) force the running program to stop,(2) have the processor execute a program that carries out the needs of the I&#x2F;O device, and then(3) have the stopped program resume execution as if nothing had happened.</p><p>Interrupt-driven I&#x2F;O do not waste time during input and output, instead, it can do useful work until it is notified that some I&#x2F;O device needs attention.</p><p><strong>Two parts to the process:</strong></p><ul><li>The mechanism that enables an I&#x2F;O device to interrupt the processor.</li><li>The mechanism that handles the interrupt request.</li></ul><p><strong>Part I:</strong></p><p><strong>Three things must be true to allow an I&#x2F;O device to interrupt the running program:</strong></p><ol><li>The I&#x2F;O device <strong>must want</strong> service: Check the ready bit in KBSR or DSR to confirm.</li><li>The device <strong>must have the right</strong> to request the service: that is the interrupt enable (IE) bit. In KBSR and DSR it is in bit[14]. The i<strong>nterrupt request signal from the I&#x2F;O device</strong> is the logical AND of the IE bit and the ready bit.</li></ol><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%203.png" alt="Untitled"></p><ol><li>The device request <strong>must be more urgent</strong> than what the processor is currently doing: it means the priority of the request must be higher than the priority of the program it wishes to interrupt.</li></ol><p><strong>The INT signal</strong></p><p>To stop the processor from continuing execution of its currently running program and service an interrupt request, the INT signal must be asserted.</p><p>The picture shows the status registers of several devices operating at various priority levels (PL). Any device that has bits [14] and [15] both set asserts its interrupt request signal. The interrupt request signals are input to a priority encoder, a combinational logic structure that selects the highest priority request from all those asserted. If the PL of that request is higher than the PL of the currently executing program, the INT signal is asserted.</p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%204.png" alt="Untitled"></p><p>Finally, the test to enable the processor to stop and handle the interrupt. Recall from Chapter 4 that the instruction cycle continually sequences through the phases of the instruction cycle (FETCH, DECODE, EVALUATE ADDRESS, FETCH OPERAND, EXECUTE, and STORE RESULT). Each instruction changes the state of the computer, and that change is completed at the end of the instruction cycle for that instruction. That is, in the last clock cycle before the computer returns to the FETCH phase for the next instruction, the computer is put in the state caused by the complete execution of the current instruction.<br>Interrupts can happen at any time. They are asynchronous to the synchronous finite-state machine controlling the computer. For example, the interrupt signal could occur when the instruction cycle is in its FETCH OPERAND phase. If we stopped the currently executing program when the instruction cycle was in its FETCH OPERAND phase, we would have to keep track of what part of the current instruction has executed and what part of the current instruction still has work to do. It makes much more sense to ignore interrupt signals except when we are at an instruction boundary; that is, the current instruction has completed, and the next instruction has not yet started. Doing that means we do not have to worry about partially executed instructions, since the state of the computer is the state created by the completion of the current instruction, period!<br>The additional logic to test for the interrupt signal is to augment the last state of the instruction cycle for each instruction with a test. Instead of always going from the last state of one instruction cycle to the first state of the FETCH phase of the next instruction, the next state depends on the INT signal. If INT is not asserted, then it is business as usual, with the control unit returning to the FETCH phase to start processing the next instruction. If INT is asserted, then the next state is the first state of Part II, handling the interrupt request.</p><p><strong>Part II:</strong></p><p>Handling the interrupt goes through 3 stages:</p><ol><li>Initiate the interrupt.</li><li>Service the interrupt.</li><li>Return from the interrupt.</li></ol><p>First: Initiate</p><p>There are two things to do:</p><ol><li>Save the state of the interrupted program: The first step is to save enough of the state of the program that is running so that it can continue where it left off after the I&#x2F;O device request has been satisfied. That means storing current PC and PSR(These are the only state information LC-3 need to store during the execution).They are saved on the supervisor stack in the same way that PC and PSR are saved when a TRAP instruction is executed.</li><li>Load the state of the interrupt service routine:</li></ol><p>Once the state of the interrupted program has been safely saved on the supervisor stack, the second step is to load the PC and PSR of the interrupt service routine. Interrupt service routines are similar to the trap service routines we have already discussed. They are program fragments stored in system space. They service interrupt requests.</p><p>Most processors use the mechanism of vectored interrupts. You are familiar with this notion from your study of the trap vector contained in the TRAP instruction. In the case of interrupts, the eight-bit vector is provided by the device that is requesting the processor be interrupted. That is, the I&#x2F;O device transmits to the processor an eight-bit interrupt vector along with its interrupt request signal and its priority level. The interrupt vector corresponding to the highest priority interrupt request is the one supplied to the processor. It is designated INTV.</p><p>If the interrupt is taken, the processor expands the 8-bit interrupt vector (INTV) to form a 16-bit address, which is an entry into the Interrupt Vector Table. You know that the Trap Vector Table consists of memory locations x0000 to x00FF, each containing the starting address of a trap service routine. The Interrupt Vector Table consists of memory locations x0100 to x01FF, each containing the starting address of an interrupt service routine. The processor loads the PC with the contents of the location in the Interrupt Vector Table corresponding to the address formed by expanding the interrupt vector INTV.</p><p>The PSR is loaded as follows: Since no instructions in the service routine have yet executed, PSR[2:0] contains no meaningful information. We arbitrarily load it initially with 010. Since the interrupt service routine runs in privileged mode, PSR[15] is set to 0. PSR[10:8] is set to the priority level associated with the interrupt request.</p><p>This completes the initiation phase, and the interrupt service routine is ready to execute.</p><p>Second: Service(OMIT)</p><p>Finally: Return</p><p>The last instruction in every interrupt service routine is RTI, which stands for “return from trap or interrupt”. When the processor finally accesses the RTI instruction, all the requirements of the I&#x2F;O device have been taken care of.</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 8</title>
      <link href="/2023/11/20/review-chap-8-4f43e889765545ecb6d7554902d57891/"/>
      <url>/2023/11/20/review-chap-8-4f43e889765545ecb6d7554902d57891/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-8"><a href="#Review-Chap-8" class="headerlink" title="Review Chap 8"></a>Review Chap 8</h1><h3 id="Subroutines"><a href="#Subroutines" class="headerlink" title="Subroutines"></a>Subroutines</h3><p>It is almost always the case that collections of fragments to invoke the program are available to user programmers to free them from writing their own. These collections are referred to as libraries.</p><p>In a library, a specified fragment can be invoked multiple times within the same program without having to specify its details. Such program fragments are called subroutines, or in C we call it functions.</p><ul><li>The Call&#x2F;Return Mechanism</li></ul><p>It allows us to execute this one three-instruction sequence multiple times by requiring us to include it as a subroutine in our program only once.</p><p>The programmer uses the call&#x2F;return mechanism to direct the computer each time via the call instruction to the code A, and after the computer has executed the code A, to the return instruction to the proper next instruction to be executed in the program.</p><p>Two instructions will be needed: JSR(R) calls the subroutinue; and RET(JMP R7) to go back to the main program.</p><ul><li><p>The JSR(R) instruction detailed</p><p>  The instruction uses one of two addressing modes for computing the starting address of the subroutine, PC-relative addressing or Base Register addressing. The LC-3 assembly language provides two different mnemonic names for the opcode, JSR and JSRR, depending on which addressing mode is used.</p><p>  The JSR (R) instruction does two things. Like all control instructions, it loads the PC, overwriting the incremented PC that was loaded during the FETCH phase of the JSR (R) instruction. In this case, the starting address of the subroutine is computed and loaded into the PC.</p><p>  The second thing the JSR (R) instruction does is save the return address in R7. The return address is the incremented PC, which is the address of the instruction following the JSR (R) instruction in the calling program.</p></li><li><p>Saving and Restoring Registers</p></li></ul><p>If a value in a register will be needed after something else is stored in that register, we must save it before something else happens and restore it before we can subsequently use it. We save a register value by storing it in memory; we restore it by loading it back into the register.</p><p>The save&#x2F;restore problem can be handled either by the calling program before the JSR occurs or by the subroutine.</p><p>In summary, we use the term “caller-save” if the calling program handles the save&#x2F;restore problem, and we use the term “callee-save” if the called program handles the problem. The appropriate one to handle the problem is the one that knows which registers will be destroyed by subsequent actions.</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>The stack is an abstract data type whose defining notion is that the last thing you stored in the stack is the first thing you remove from it. Simply, Last In, First Out, LIFO.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled.png" alt="Untitled"></p><p>In a stack implemented in hardware, as each value is added or removed, <strong>all the other values already on the stack move.</strong></p><ul><li>Implementation in Memory</li></ul><p>In the LC-3, R6 is the stack pointer.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%201.png" alt="Untitled"></p><p>These show the implementation in memory. Different from hardware,</p><p>Figure 8.9a shows an initially empty stack. Since there are no values on the stack, the stack pointer contains the address x4000, which is the address of the memory location just after the memory locations reserved for the stack. This setup makes sense because as we will see through the code for pushing and popping values, the stack grows towards zero.</p><p>Figure 8.9b illustrates the stack after pushing the value 18. Notice that the stack pointer now contains the address x3FFF, which becomes the new top of the stack.</p><p>In Figure 8.9c, we can see the stack after pushing the values 31, 5, and 12 in that order. It is important to note that the values inserted into the stack are stored in memory locations with decreasing addresses, as the stack grows towards zero.</p><p>Lastly, Figure 8.9d demonstrates the stack after popping the top two elements off the stack. The values 5 and 12, which were popped, are still present in memory locations x3FFD and x3FFC, respectively. However, these values cannot be accessed from memory as long as every access to memory is controlled by the stack mechanism.</p><p>Unlike the coin holder and computer hardware stack implementations discussed in the previous section, when values are pushed and popped to and from a stack implemented in sequential memory locations, the data already stored on the stack does not physically move.</p><ul><li>Underflow and Overflow</li></ul><ol><li>Underflow: Underflow happens when an attempt is made to pop a value from an empty stack. In other words, the stack is already empty, but a pop operation is requested. This results in an error condition because there are no values to retrieve from the stack. It is important to check for underflow conditions before performing a pop operation to avoid data loss or program malfunction.</li><li>Overflow: Overflow occurs when an attempt is made to push a value onto a stack that is already full. In LC-3, the stack is implemented within a defined region of memory with a fixed size. When the stack becomes full and additional values need to be pushed onto it, an overflow condition arises. This can lead to data corruption or unpredictable behavior in the program. It is crucial to monitor the stack usage and prevent overflow situations by appropriately managing the stack size or implementing error handling mechanisms.</li></ol><p>Both underflow and overflow conditions can be detected by monitoring the stack pointer and checking its position relative to the stack boundaries. Handling these scenarios effectively is essential to ensure the proper functioning and integrity of programs using the LC-3 stack.</p><p>Here are a complete picture, from which you can detect the way to avoid underflow and overflow.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%202.png" alt="Untitled"></p><h3 id="Recursion-a-Powerful-Technique-When-Used-Appopriately"><a href="#Recursion-a-Powerful-Technique-When-Used-Appopriately" class="headerlink" title="Recursion, a Powerful Technique When Used Appopriately"></a>Recursion, a Powerful Technique When Used Appopriately</h3><p>Recursion is a mechanism for expressing a function in terms of itself.</p><p>Good Example：a maze</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%203.png" alt="Untitled"></p><h3 id="The-Queue"><a href="#The-Queue" class="headerlink" title="The Queue"></a>The Queue</h3><p>Unlike the stack, it is FIFO(first in first out). This means we need to keep track of two ends of the storage structure: a FRONT pointer for servicing and a REAR pointer for entering. Here are an example.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%204.png" alt="Untitled"></p><p>The basic operations: Remove from front, Insert at rear.</p><p>Wrap-Around: It works by having our removal and insertion algorithms test the contents of FRONT and REAR for the value x8005. If we wish to insert, and REAR contains x8005, we know we have reached the end of our available storage and we must see if x8000 is available. If we wish to remove, we must see if FRONT contains the address x8005. If it does, the front of the queue is in x8000.</p><ul><li><strong>NOTE:</strong> We cannot let the empty queue and the full queue look the same, What should we do?</li></ul><p>Our answer is to allow the queue to store only n-1 elements if space for n elements has been allocated. That means, if inserting a nth element into the queue would cause FRONT to equal REAR, we do not allow that insertion. We declare the queue full when there are n-1 elements in the queue.</p><p>If the queue is empty, FRONT&#x3D;REAR.</p><p>Test of UNDERFLOW: just test if R3&#x3D;R4. If so, it means it is already empty.</p><p>Test of OVERFLOW: similarly, just add 1 to the REAR, if R3&#x3D;R4, it means it is already full.</p><h3 id="Character-Strings-Omit"><a href="#Character-Strings-Omit" class="headerlink" title="Character Strings(Omit)"></a>Character Strings(Omit)</h3>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 6&amp;7</title>
      <link href="/2023/11/14/review-chap-6-7-e66b76be92614538a66fb9a1d93b9783/"/>
      <url>/2023/11/14/review-chap-6-7-e66b76be92614538a66fb9a1d93b9783/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-6-7"><a href="#Review-Chap-6-7" class="headerlink" title="Review Chap 6&amp;7"></a>Review Chap 6&amp;7</h1><p>Away from machine codes, we are going to talk about programming languages. There are high-level and low-level languages. High-level languages tend to be ISA independent.</p><p>Assembly language is a low-level language. Low-level languages are ISA dependent. In fact, it is usually the case that each ISA has only one assembly language.</p><ul><li><em>Symbolic Addresses :</em> meaningful symbolic names to memory locations, such as SUM and PRODUCT, rather than use the memory locations’ 16-bit addresses. This makes it easier to differentiate which memory location is keeping track of a SUM and which memory location is keeping track of a PRODUCT.</li></ul><p>An Assembly Language Program</p><ul><li>The translation <strong>program</strong> is called an <strong>assembler</strong>, and the translation <strong>process</strong> is called <strong>assembly</strong>.</li><li>In LC-3 ISA, an instruction in assembly language consists of four parts:</li><li><code>Label Opcode Operands ; Comment</code></li><li><em><strong>Label</strong> &amp; <strong>Comment</strong> are optional, <strong>Opcode</strong> &amp; <strong>Operands</strong> are <strong>mandatory</strong></em>.</li></ul><p><strong>Opcode</strong> &amp; <strong>Operands</strong></p><ul><li>The <strong>Opcode</strong> is a symbolic name for the opcode of the corresponding LC-3 instruction.</li><li>The number of operands depends on the operation being performed.</li><li>A literal value must contain a symbol identifying the representation base of the number. We use <code>#</code> for decimal, <code>x</code> for hexadecimal, and <code>b</code> for binary.</li></ul><p><strong>Labels</strong></p><ul><li>Labels are symbolic names that are used to <strong>identify memory locations</strong> that are referred to explicitly in the program.</li><li>Label 实际上是给特定内存的一个 alias，因此你可以用它标记 instructions，也可以用它索引 data！</li><li>In LC-3 assembly language, a label consists of from 1 to 20 <strong>alphanumeric characters</strong> (i.e., each character is a capital or lower-case letter of the English alphabet, or a decimal digit), starting with a letter of the alphabet except <strong>reserved words</strong>.</li><li>There are two reasons for explicitly referring to a memory location:</li></ul><ol><li>The location is the <strong>target</strong> of a <strong>branch</strong> instruction.</li><li>The location contains a <strong>value</strong> that is <strong>loaded</strong> or <strong>stored</strong>.</li></ol><p><strong>Comments</strong></p><ul><li>The purpose of comments is to make the program more comprehensible to the human reader.</li><li>It is important to make comments that provide additional insight and do not just restate the obvious.</li><li>Another purpose of comments is to make the visual presentation of a program easier to understand.</li></ul><p><strong>Pseudo-Ops(Assembler Directives)</strong></p><ul><li>.ORIG: it tells the assembler where in memory to place the LC-3 program. e.g.: .ORIG x3000</li><li>.FILL: it tells the assembler to set aside the next location in the program and initialize it with the value of the operand. The value can be either a number or a label.</li><li>.BLKW: it tells the assembler to set aside some number of sequential memory locations(i.e., a BLocK of Words) in the program.</li><li>.STRINGZ: it tells the assembler to initialize a sequence of n+1 memory locations.</li></ul><p>It would result in the assembler initializing locations <code>x3010</code> through <code>x301D</code> to the following values:</p><p><img src="/Review%20Chap%206&7%20e66b76be92614538a66fb9a1d93b9783/Untitled.png" alt="Untitled"></p><ul><li>.END: it tells the assembler it has reached the end of the program and need not even look at anything after it. (In fact, .END does not exist at the time of execution, it is simply a delimiter)</li></ul><h3 id="The-Assembly-Process"><a href="#The-Assembly-Process" class="headerlink" title="The Assembly Process"></a>The Assembly Process</h3><p>Introduction</p><ul><li>If you have available an LC-3 assembler, you can cause it to translate your assembly language program into a machine language program by executing an appropriate command. In the LC-3 assembler that is generally available via the web, that command is assemble, and it requires as an argument the filename of your assembly language program.</li><li>eg: <code>assemble solution1.asm outfile</code></li></ul><p>A Two-Pass Process</p><ul><li>The objective of the first pass is to <strong>identify</strong> the actual binary <strong>addresses</strong> corresponding to the symbolic names (or <strong>labels</strong>). This set of correspondences is known as the <strong>symbol table</strong>.</li><li>In pass 1, we <strong>construct</strong> the <strong>symbol table</strong>. In pass 2, we <strong>translate</strong> the individual <strong>assembly language instructions</strong> into their corresponding <strong>machine language instructions</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 5</title>
      <link href="/2023/11/11/review-chap-5-ddcbb3165ab44277adc7d7cbc629f81c/"/>
      <url>/2023/11/11/review-chap-5-ddcbb3165ab44277adc7d7cbc629f81c/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-5"><a href="#Review-Chap-5" class="headerlink" title="Review Chap 5"></a>Review Chap 5</h1><ul><li><p>ISA(omit)</p><p>  The ISA specifies all the information about the computer that the software has to be aware of.</p><p>  The ISA specifies the memory organization, register set,and instruction set,including the opcodes, data types, and addressing modes of instructions in the instruction set.</p><p>  There are 65536 memory locations in LC-3, and 8 registers. We refer to 16 bits as one word, and we say the LC-3 is word-addressable.</p><p>  Each register in the set is called a general purpose register(GPR).</p><p>  Register file: what does every register contain.</p><ul><li><p>The instruction set: defined by its set of opcodes, data types and addressing modes.</p><p>  The addressing modes determine where the operands are located. The data type is the representation of operands in 0s and 1s.</p><h3 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h3><ul><li>Some ISAs have a very large number of opcodes, one for each of a very large number of tasks that a program may wish to carry out.</li><li>There are three different types of instructions, which means three different types of opcodes: operates, data movement, and control.</li><li>Operate instructions <strong>process</strong> information.</li><li>Data movement instructions <strong>move</strong> information between memory and the registers and between registers&#x2F;memory and input&#x2F;output devices.</li><li>Control instructions <strong>change</strong> the sequence of instructions that will be executed.</li></ul><p>  <strong>Data Types</strong></p><ul><li>Every opcode will <strong>interpret</strong> the bit patterns of its operands according <strong>to</strong> the data type it is designed to support.</li></ul><p>  <strong>Addressing Modes</strong></p><ul><li>An <strong>addressing mode</strong> is a mechanism for specifying where the operand is located.</li><li>LC-3 supports five addressing modes:</li><li><strong>immediate</strong>&#x2F;<strong>literal</strong> (the same)</li><li><strong>register</strong></li><li>3 <strong>memory</strong> addressing modes:</li><li><strong>PC-relative</strong></li><li><strong>indirect</strong></li><li><strong>Base+offset</strong></li></ul></li></ul></li></ul><p><img src="/Review%20Chap%205%20ddcbb3165ab44277adc7d7cbc629f81c/Untitled.png" alt="Untitled"></p><ul><li><strong>Condition Codes（CC）</strong></li><li>The LC-3 has three single-bit registers that are individually set (set to 1) or cleared (set to 0) <strong>each time</strong> one of the eight general purpose registers is written into <strong>as a result</strong> of execution of one of the operate instructions or one of the load instructions.</li><li>Each <strong>operate instruction</strong> performs a computation and writes the result into a general purpose register.</li><li>Each <strong>load instruction</strong> reads the contents of a memory location and writes the value found there into a general purpose register.</li><li>The three single-bit registers are called <strong>N</strong>, <strong>Z</strong>, and <strong>P</strong>, corresponding to their meaning: <strong>n</strong>egative, <strong>z</strong>ero, and <strong>p</strong>ositive. And their value will be modified each time a GPR is written by an operate or a load instruction.</li><li>They are referred to as condition codes because the condition of those bits are used to change the sequence of execution of the instructions in a computer program. (e.g. <code>BR</code>‘s condition.)</li></ul><p>结果我研究每个指令的数据通路又给我绕晕了。。。我是真菜</p><ul><li><strong>Operate Instructions</strong></li><li><strong><code>ADD</code></strong>, <strong><code>AND</code></strong>, and <strong><code>NOT</code></strong></li><li>The <strong><code>NOT</code></strong> (opcode &#x3D; 1001) instruction is the only (in LC-3) operate instruction that performs a <strong>unary</strong> operation. See docs for details.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856236536-0606ce17-259e-4116-88ab-9d382a258c6b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_17,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856236536-0606ce17-259e-4116-88ab-9d382a258c6b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Inmmediates</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856377554-22f4fbf6-f586-4caa-acfe-214c1203dfaf.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856377554-22f4fbf6-f586-4caa-acfe-214c1203dfaf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Since the immediate operand havs a size less than a word, so not all 2’s complement integers can be immediate operands.</li><li>The <strong>LEA</strong> Instruction (Although Not Really an Operate)</li><li>It does not really operate on data, it simply <strong>loads</strong> a register with an <strong>address</strong>. It clearly does not move data from memory to a register, nor is it a control instruction. We had to put it somewhere, so we chose to discuss it here! See docs for details.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856727821-214fb9a4-b5f3-4318-ab7d-a7b0fb9d0d59.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856727821-214fb9a4-b5f3-4318-ab7d-a7b0fb9d0d59.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>We shall see shortly that the LEA instruction is useful to <strong>initialize</strong> a register with an address that is very close to the address of the instruction doing the initializing.</li><li><strong>Data Movement Instructions</strong></li><li><em>We will ignore for now the business of moving information from input devices to registers and from registers to output devices which will be an important part of Chapter 9.</em>  <em>In this chapter, we will confine ourselves to moving information between memory and the general purpose registers.</em></li><li>The process of moving information from memory to a register is called a <strong>load</strong>.</li><li>The process of moving information from a register to memory is called a <strong>store</strong>.</li><li>In both cases, the information in the location containing the <strong>source</strong> operand remains <strong>unchanged</strong>.</li><li>In both cases, the location of the <strong>destination</strong> operand is <strong>overwritten</strong>.</li><li>The LC-3 contains six instructions that move information: <strong><code>LD</code></strong>, <strong><code>LDR</code></strong>, <strong><code>LDI</code></strong>; <strong><code>ST</code></strong>, <strong><code>STR</code></strong>, <strong><code>STI</code>.</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857321834-ff385e31-c387-4306-9960-d3234706d177.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_20,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857321834-ff385e31-c387-4306-9960-d3234706d177.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Data movement instructions require two operands, a <strong>source</strong> and a <strong>destination</strong>.</li><li><strong>PC-Relative Mode</strong></li><li><strong><code>LD</code></strong> and <strong><code>ST</code></strong> specify the PC-relative addressing mode.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857885236-4a6ff41d-4d30-4211-b725-728f7927fa3d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857885236-4a6ff41d-4d30-4211-b725-728f7927fa3d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Indirect Mode</strong></li><li><strong><code>LDI</code></strong> and <strong><code>STI</code></strong> specify the <strong>indirect</strong> addressing mode that means the <strong>address</strong> of the address of the operand to be loaded or stored.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858056522-1fa1bc60-4bf1-48b5-87ef-5b98b3335631.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_20,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858056522-1fa1bc60-4bf1-48b5-87ef-5b98b3335631.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>在寻址过程中进行一次迭代，用 C 的<code>[]</code>符号写的话感觉就像是<code>mem[ mem[idx] ]</code>。</li><li><strong>Base+offset Mode</strong></li><li><code>LDR</code> and <code>STR</code> specify the <strong>Base+offset</strong> addressing mode. The Base+offset mode is so named because the address of the operand is obtained by <strong>adding</strong> a sign-extended six-bit <strong>offset</strong> to a <strong>base register</strong>.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858232090-0d249491-0b39-4e60-8f72-96893439de0b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858232090-0d249491-0b39-4e60-8f72-96893439de0b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Note that the Base+offset addressing mode also allows the address of the operand to be <strong>anywhere</strong> in the computer’s memory.</li><li>所以因为这个特性，这种寻址模式是在长距离跳转中较为实用的。</li></ul><h3 id="Control-Instructions"><a href="#Control-Instructions" class="headerlink" title="Control Instructions"></a>Control Instructions</h3><p>The LC-3 has five opcodes that enable the sequential execution flow to be broken:</p><ul><li>conditional branch</li><li>unconditional jump</li><li>subroutine call (sometimes called function)</li><li><strong><code>TRAP</code></strong> (service call)</li><li><strong><code>RTI</code></strong> (Return from Trap or Interrupt)</li></ul><p>Two Methods of <strong>Loop</strong> Control</p><ul><li><strong>loop body</strong> &amp; <strong>iteration</strong> fo the loop body</li><li>Loop Control with a <strong>Counter</strong></li><li>Loop Control with a <strong>Sentinel</strong></li><li>We append to our sequence of values to be processed a value that we know ahead of time can <strong>never occur</strong> (i.e., the <strong>sentinel</strong>).</li><li>就是需要一个哨兵标记序列的尾部，当访问到该哨兵的时候跳出循环。</li><li>eg: if we are adding a sequence of numbers, a sentinel could be a letter <code>A</code> or a &#96;&#96;, that is, something that is not a number.</li><li>BR instruction</li></ul><p><img src="/Review%20Chap%205%20ddcbb3165ab44277adc7d7cbc629f81c/Untitled%201.png" alt="Untitled"></p><ul><li>JMP Instruction TRAP instruction(我们会在后面的章节中讨论他们，现在还不是时候）</li><li>Another Example: Counting Occurrences of a Character</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859510501-fb0532f9-02e7-4319-bf78-37597547c1dc.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_11,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859510501-fb0532f9-02e7-4319-bf78-37597547c1dc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_11%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859523144-18c15d17-9367-4960-a418-6f7e62391d6e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_18,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859523144-18c15d17-9367-4960-a418-6f7e62391d6e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>The Data Path Revisited</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859746575-60df7310-d152-4bec-80b2-b965ade04159.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_23,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859746575-60df7310-d152-4bec-80b2-b965ade04159.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Basic Components</strong> of the Data Path</li><li>The <strong>Global Bus</strong></li><li>The LC-3 global bus consists of <strong>16</strong> wires and associated electronics. It allows one structure to transfer up to 16 bits of information to another structure by making the necessary electronic connections on the bus.</li><li>Note that each structure that supplies values to the bus has a triangle just behind its input arrow to the bus. This triangle (called a <strong>tri-state device</strong>) allows the computer’s control logic to enable exactly one supplier to provide information to the bus at any one time.</li><li>The pros and cons of a <strong>single global bus</strong> is yet another topic that will have to wait for later in your education.</li><li><strong>Memory</strong></li><li>One of the most important parts of any computer is the memory that <strong>contains both instructions and data</strong>.</li><li>Memory is accessed by loading the memory address register (<strong>MAR</strong>) with the address of the location to be accessed. To perform a load, control signals then read the contents of that memory location, and the result of that read is delivered by the memory to the memory data register (<strong>MDR</strong>). On the other hand, to perform a store, what is to be stored is loaded into the <strong>MDR</strong>. Then the control signals assert a write enable (<strong>WE</strong>) signal in order to store the value contained in <strong>MDR</strong> in the memory location specified by MAR.</li><li>The <strong>ALU</strong> and the <strong>Register File</strong></li><li>The results of an ALU operation are (a) a <strong>result</strong> that is stored in one of the registers, and (b) the three single-bit <strong>condition codes</strong>.</li><li>The <strong>PC</strong> and the <strong>PCMUX</strong></li><li>The <strong>MARMUX</strong></li><li>The <strong>Instruction Cycle Specific to the LC-3</strong></li><li><strong>FETCH</strong></li><li><strong>DECODE</strong></li><li><strong>EVALUATE ADDRESS</strong></li><li><strong>OPERAND FETCH</strong></li><li><strong>EXECUTE</strong></li><li><strong>STORE RESULT</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 4</title>
      <link href="/2023/11/09/review-chap-4-db0804e57cb947bda974a470320dbd90/"/>
      <url>/2023/11/09/review-chap-4-db0804e57cb947bda974a470320dbd90/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-4"><a href="#Review-Chap-4" class="headerlink" title="Review Chap 4"></a>Review Chap 4</h1><p>To get a task done by a computer, we need two things: (a) a <strong>computer program</strong> that specifies what the computer must do to perform the task, and (b) the <strong>computer</strong> that is to carry out the task.</p><ul><li>The <strong>instruction</strong> is the smallest piece of work specified in a computer program.</li><li>John von Neumann proposed a fundamental model of a computer for processing computer programs in 1946. Here is it’s basic components:</li></ul><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/1692688049747.png" alt="1692688049747.png"></p><ul><li>Memory</li></ul><p>For nowadays computer: 2^34 by 8 bits.</p><p>Addressability: 8 bits.</p><p>Address space: 2^34.</p><p>Each location has 34-bit address, for n bits can represent unique ly 2^n items.</p><ul><li>MAR and MDR</li></ul><p>To write (or store) a value in a memory location, we first write <strong>the address of the memory location</strong> in the <strong>MAR</strong> (memory’s address register), the value (interrogated from the computer’s memory) to be stored in the <strong>MDR</strong> (memory’s data register).这并不意味着 MDR 里存的不可能是个地址！</p><p>The <strong>address of that location</strong> will be written to the (<strong>MAR</strong>) and then we <strong>interrogate the computer’s memory</strong>.</p><p>The <strong>information stored</strong> in the location having that address will be placed in the <strong>m</strong>emory’s <strong>d</strong>ata <strong>r</strong>egister (<strong>MDR</strong>).</p><ul><li>Processing Unit</li></ul><p>The actual processing of information in the computer is carried out by the processing unit. The processing unit in a modern computer can consist of many sophisticated complex functional units, each performing one particular operation.</p><p><strong>ALU:</strong> the simplest processing unit, is the abbreviation for Arithmetic and Logic Unit, which is capable of performing basic arithmetic functions and basic logic operations.</p><p>In LC-3, ALU can perform ADD, AND, and NOT operations.</p><ul><li>Each ISA has its own word length, depending on the intended use of the computer.</li><li>Most microprocessors today that are used in PCs or workstations have a word length of 64 bits (as is the case with Intel’s “Core” processors) or 32 bits (as is the case with Intel’s “Atom” processors). Even most microprocessors now used in cell phones have 64-bit word lengths, such as Apple’s A7 through A11 processors, and Qualcomm’s SnapDragon processors. However, the microprocessors used in very inexpensive applications often have word lengths of as little as 16 or even 8 bits.</li><li>LC-3 has a word length of 16 bits.</li><li>It is almost always the case that a computer provides some <strong>small amount of storage</strong> very close to the ALU to allow results to be <strong>temporarily stored</strong> if they will be needed to produce additional results <strong>in the near future</strong>. (They are important.)</li><li>The most common form of temporary storage is a set of <strong>registers</strong>.</li><li>Typically, the size of each register is identical to the size of values processed by the ALU; that is, they <strong>each contain one word</strong>.</li><li>Current microprocessors typically contain 32 registers, each consisting of 32 or 64 bits, depending on the architecture.</li><li>The LC-3 has eight registers (R0, R1, … R7), each containing 16 bits.</li></ul><p>也就是一般会涉及一些寄存器来存储计算的中间结果。</p><ul><li>Input and Output(好像不重要）</li><li>Control Unit（it is like the conductor of an orchestra)</li></ul><p>The control unit has an instruction register to contain that instruction to keep track of which instruction is being executed. And to keep track of which instruction is to be happened next, the control unit has a register contains next instruction’s address, which is called program counter(PC).</p><h1 id="The-LC-3-An-Example-von-Neumann-Machine"><a href="#The-LC-3-An-Example-von-Neumann-Machine" class="headerlink" title="The LC-3: An Example von Neumann Machine"></a>The LC-3: An Example von Neumann Machine</h1><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/Untitled.png" alt="Untitled"></p><ul><li><p>Two kinds of arrowheads:</p></li><li><p>Filled-in: denote data elements that flow along the corresponding paths.</p><p>  <img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687710479-37d632d3-4794-4a2b-8330-c944922c689e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_9,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687710479-37d632d3-4794-4a2b-8330-c944922c689e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p></li><li><p>Not-filled in: denote control signals that control the processing of the data elements.</p><p>  <img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687737528-a4ac7ebd-3c0b-4ec3-8f7a-22bd2aeb64c9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_9,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687737528-a4ac7ebd-3c0b-4ec3-8f7a-22bd2aeb64c9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p>  <strong>MEMORY</strong> consists of the storage elements, along with the <strong>MAR</strong> for addressing individual locations and the <strong>MDR</strong> for holding the contents of a memory location on its way to&#x2F;from the sotrage.</p><ul><li>NOTE: the <strong>MAR</strong> and <strong>MDR</strong> each contains 16 bits, reflecting the fact that the memory address space of the LC-3 is 2^16 <strong>memory locations</strong> and the LC-3 is <strong>16-bit addressable</strong>.</li></ul><p>  <strong>INPUT&#x2F;OUTPUT</strong> consists of a keyboard and a monitor.</p><ul><li>The simplest keyboard requires two registers: a <strong>KBDR</strong> (<strong>k</strong>ey<strong>b</strong>oard <strong>d</strong>ata <strong>r</strong>egister) for holding the ASCII codes of keys struck and a <strong>KBSR</strong> (<strong>k</strong>ey<strong>b</strong>oard <strong>s</strong>tatus <strong>r</strong>egister) for maintaining status information about the keys struck.</li><li>The simplest monitor requires two registers: a <strong>DDR</strong> (<strong>d</strong>isplay <strong>d</strong>ata <strong>r</strong>egister) for holding the ASCII code of something to be displayed on the screen and a <strong>DSR</strong> (<strong>d</strong>isplay <strong>s</strong>tatus <strong>r</strong>egister) for maintaining associated status information.</li></ul><p>  <strong>THE PROCESSING UNIT</strong> consists of a <strong>functional unit</strong> (<strong>ALU</strong> here) that performs arithmetic and logic operations and <strong>eight registers</strong> (R0, … R7) for storing temporary values that will be needed in the near future as operands for subsequent instructions.</p><ul><li>The LC-3 ALU can perform one <strong>arithmetic</strong> operation (<strong>addition</strong>) and two <strong>logical</strong> operations (<strong>bitwise AND</strong> and <strong>bitwise NOT</strong>).</li></ul><p>  <strong>THE CONTROL UNIT</strong> consists of all the structures needed to <strong>manage</strong> the processing that is carried out by the computer.</p><ul><li>Its most important structure is the <strong>finite state machine</strong>, which directs all the activity.</li><li>Note the <strong>CLK</strong> input to the finite state machine. It specifies how long each clock cycle lasts.</li><li>The <strong>IR</strong> (<strong>i</strong>nstruction <strong>r</strong>egister) is also an input to the finite state machine since the LC-3 instruction being processed determines what activities <strong>must</strong> be carried out.</li><li>The <strong>PC</strong> (<strong>p</strong>rogram <strong>c</strong>ounter) is also a part of the control unit; it keeps track of the next instruction to be executed after the current instruction finishes.</li><li>Note that all the external <strong>outputs</strong> of the <strong>finite state machine</strong> in the figure have arrowheads that are <strong>not filled in</strong>. These outputs <strong>control</strong> the <strong>processing</strong> throughout the computer.</li><li>eg: <strong>ALUK</strong>: controls the <strong>operation</strong> performed in the <strong>ALU</strong> (<strong>ADD</strong>&#x2F;<strong>AND</strong>&#x2F;<strong>NOT</strong>) during the current clock cycle.</li><li>eg: <strong>GateALU</strong>: determines whether or not the output of the ALU is provided to the <strong>processor bus</strong> during the current clock cycle.</li><li>即有限元状态机的所有输出都非计算数据，而是用来控制各个元件，控制指令行为的。</li></ul><h1 id="Instruction-Processing"><a href="#Instruction-Processing" class="headerlink" title="Instruction Processing"></a>Instruction Processing</h1><p>  The central idea in the von Neumann model of computer processing is that the program and data are both stored as sequences of bits in the computer’s memory, and the program is executed one instruction at a time under the ditrection of the control unit.</p><ul><li>The instruction is made up of two parts, the opcode(what the instruction does) and the operands(who it does it to).</li><li>Three kinds of instructions: <em>operates</em>, <em>data movement</em>, and <em>control</em>.</li><li><strong>Operate</strong> instructions operate on data.</li><li>LC-3 has three operate instructions: <strong>ADD</strong>&#x2F;<strong>AND</strong>&#x2F;<strong>NOT</strong></li><li><strong>Data movement</strong> instructions move information from the processing unit to and from memory ****and to&#x2F;from input&#x2F;output devices.</li><li>The LC-3 has six data movement instruction： <em><em>LD</em>&#x2F;ST</em>**.</li><li><strong>Control</strong> instructions are necessary for altering the sequential processing of instructions. （比如指令间的跳转啥的）</li><li>An LC-3 instruction consists of 16 bits (one word), numbered from left to right, bit [15] to bit [0].</li><li><strong>Bits [15:12]</strong> contain the <strong>opcode</strong>. This means there are at most 16 distinct opcodes. Actually, we use only 15 of the possible four-bit codes. One is reserved for some future use.</li><li><strong>Bits [11:0]</strong> are used to figure out <strong>where the operands are</strong>.</li></ul><p>  至于15个指令都是什么。。。我累了，翻appendix A看吧.</p></li></ul><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/Untitled%201.png" alt="Untitled"></p><ul><li>The Instruction Cycle(Not the Clock Cycle!)</li></ul><p>The entire sequence of steps needed to process an instruction is called the <em>instruction cycle.</em></p><p>Here are the six sequential phases of the instruction cycle:</p><p><strong>FETCH</strong></p><ul><li>The FETCH phase obtains the next instruction from memory and loads it into the <strong>IR</strong> (instruction register) of the control unit.</li><li>The <strong>PC</strong> contains the address of the next instruction to be processed.</li><li>So the FETCH do the following things:</li><li>Load the MAR with the contents of the PC, and simultaneously <strong>increment</strong> the <strong>PC</strong>. <em>[one clock cycle]</em></li><li>Interrogate memory, resulting in the instruction being placed in the MDR. <em>[one clock cycle or more]</em></li><li>Load the IR with the contents of the MDR. <em>[one clock cycle]</em></li><li>Each of these steps is under the direction of the <strong>control unit</strong>.</li><li>获取指令数据，并更新控制模块。</li></ul><p><strong>DECODE</strong></p><ul><li>The DECODE phase examines the instruction in order to figure out what the microarchitecture is being asked to do.</li><li>依据 opcode 进行路由，找到接下来要做什么。</li></ul><p><strong>EVALUATE ADDRESS</strong></p><ul><li>This phase computes the address of the memory location that is needed to process the instruction.</li><li>For instructions that needn’t deal with an address (such as ADD with bits [5] &#x3D; 0), the EVALUATE ADDRESS phase is not needed.</li><li>对于部分指令，它们涉及一个需要计算才能得到的地址，而这个计算过程就是在这一部执行。</li></ul><p><strong>FETCH OPERANDS</strong></p><ul><li>This phase obtains the source operands needed to process the instruction.</li></ul><p><strong>EXECUTE</strong></p><ul><li>This phase carries out the execution of the instruction.</li></ul><p><strong>STORE RESULT</strong></p><ul><li>The final phase of an instruction’s execution. The result is written to its designated destination.</li><li>Not all instructions require all six phases.</li></ul><p><strong>Control of the Instruction Cycle</strong></p><ul><li>The instruction cycle is controlled by a synchronous finite state machine.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657770087716-bcd10ab5-5c28-45ea-af94-981a5407dbac.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_23,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657770087716-bcd10ab5-5c28-45ea-af94-981a5407dbac.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Halting</strong> the Computer (the <strong>TRAP</strong> Instruction)</li></ul><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/Untitled%202.png" alt="Untitled"></p><ul><li>If we need to stop this potentially infinite sequence of instruction cycles, we should stop the <strong>clock</strong>.</li><li>就是通过自陷来委托计算机进行一些用户权限无法完成的事情。类似于将某些涉及到底层的行为封装起来，来增加安全性。</li><li>In the LC-3, as in many other machines, it is done under control of the operating system. For now it is enough to know that if a user program requires help from the operating system, it requests that help with the <strong>TRAP</strong> instruction (opcode &#x3D; 1111) and an eight-bit code called a <strong>trap vector</strong>, which identifies the help that the user program needs. The eight-bit code <strong>x25</strong> tells the operating system that the program has finished executing and the computer can stop processing instructions.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 3</title>
      <link href="/2023/11/05/review-chap-3-d0d116bbfd7a4a57bb62227c9d2c6bc8/"/>
      <url>/2023/11/05/review-chap-3-d0d116bbfd7a4a57bb62227c9d2c6bc8/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-3"><a href="#Review-Chap-3" class="headerlink" title="Review Chap 3"></a>Review Chap 3</h1><ul><li><p>Transistor: MOS transistors, which are below our lowest level of abstraction. Transistor has three terminals: the <strong>gate</strong>, the <strong>source</strong> and the <strong>drain</strong>.</p></li><li><p>Two types of MOS: P-type, when the gate is supplied with 0 volts, it acts as a piece of wire(short circuit), when supplied with 1.2 volts, it acts like an open circuit; N-type, which is opposite to P-type. when there are no volts, it acts like an open circuit, when there are 1.2 volts in the gate, it acts like a piece of wire(short circuit).</p><p>  <img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled.png" alt="Untitled"></p>  <aside>  💡 N-type    </aside>  <p>  <img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%201.png" alt="Untitled"></p>  <aside>  💡 P-type    </aside>  <p>  在使用上，N 管和 P 管的使用方向是反过来的，并且在充当开关时，一般以 N 管作下管，P 管做上管，主要原理参考<a href="https://zhuanlan.zhihu.com/p/96545244">这篇文章</a>。可以发现，在简化图中看不出哪头是源极哪头是漏极，只在 Gate 处加了一个非来表示，但是实际上两个的使用方向大概是相反的（例如下图）</p></li></ul><h1 id="Logic-Gates"><a href="#Logic-Gates" class="headerlink" title="Logic Gates"></a>Logic Gates</h1><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%202.png" alt="Untitled"></p><aside>💡 The NOT Gates (Inverter)</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%203.png" alt="Untitled"></p><aside>💡 The NOR Gates</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%204.png" alt="Untitled"></p><aside>💡 The OR Gates</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%205.png" alt="Untitled"></p><aside>💡 AND Gates (AB-D)       and        NAND Gates (AB-C)</aside><p>• 可以发现，与或门的设计都是从与非和或非开始的，而其结构的上半部分是一个“或”选择高电势的关系，下半部分是“与”选择接地的关系，深入感受一下这一层，就会发现这些电路都很好设计。</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%206.png" alt="Untitled"></p><aside>💡 raise our level of abstraction and use the symbols here</aside><p>Also, you can consider using gates with more than two inputs, whose truth table can be easy to draw.</p><h1 id="Combinational-Logic-Circuits"><a href="#Combinational-Logic-Circuits" class="headerlink" title="Combinational Logic Circuits"></a>Combinational Logic Circuits</h1><p>1.Decoder</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%207.png" alt="Untitled"></p><ul><li>Exactly one of its outputs is 1 and all the rest are 0s.</li><li>In general, decoders have n  inputs and  2^n outputs.</li><li>We say the output line that detects the input pattern is <a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">🔗</a><strong>asserted</strong>.</li><li>The decoder is useful in determining how to interpret a bit pattern.</li></ul><ol><li>Mux(multiplexer): to select one of the inputs and connect it to the output.</li></ol><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%208.png" alt="Untitled"></p><aside>💡 a 2-to-1 mux, (c) shows the standard representation for a mux</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%209.png" alt="Untitled"></p><aside>💡 a four-input mux, (c) shows the standard representation for a four-input mux</aside><ul><li>The select signal (S in Figure 3.12) determines which input is connected to the output.</li><li>We say S selects the source of the mux (either A or B) to be routed through to the output C.</li><li>In general, a mux consists of 2^n inputs and n select lines.</li><li>用来实现输入的<strong>路由</strong>，有点像铁轨的变道装置，通过 S 的数据来选择使用哪一条输入。</li></ul><ol><li>One-Bit Adder (Full Adder)</li></ol><p>The truth table of it is below.</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2010.png" alt="Untitled"></p><ul><li>It describes the result of binary addition on <strong>one column</strong> of bits within two <em>n</em>bit operands.</li><li>Aj and Bj are digits from inputs,Cj is the carry number from  Aj-1 + Bj-1 , and Sj is the (j+1)th digit of output.</li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2011.png" alt="Untitled"></p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2012.png" alt="Untitled"></p><p>如果不考虑进位的话，这是一个半加器；（如图中最右边）考虑进位的话，这是一个全加器（如其他部分）。</p><ol><li>The Programmable Logic Array(PLA) in Chinese:可编程阵列</li></ol><ul><li>The implementation algorithm is simply to connect the output of an AND gate to the input of an OR gate if the corresponding row of the truth table produces an output 1 for that output column. Hence the notion of <strong>programmable</strong>. That is, we say we program the connections from AND gate outputs to OR gate inputs to implement our desired logic functions.</li><li><strong>Logical Completeness</strong></li></ul><p> We say that the set of gates {AND, OR, NOT} is <strong>logically complete</strong> because we can build a circuit to carry out the specification of any truth table we wish without using any other kind of gate.</p><h1 id="Basic-Storage-Elements"><a href="#Basic-Storage-Elements" class="headerlink" title="Basic Storage Elements"></a>Basic Storage Elements</h1><h2 id="R-S-Latch"><a href="#R-S-Latch" class="headerlink" title="R-S Latch"></a>R-S Latch</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2013.png" alt="Untitled"></p><p>R-S latch can store a bit of information. And the circuit is above.</p><ul><li><strong>R</strong> : <strong>R</strong>esetting : setting the latch to store a <strong><code>0</code></strong>;</li><li><strong>S</strong> : <strong>S</strong>etting: setting the latch to store a <strong><code>1</code></strong>;</li><li>The <strong>Quiescent</strong> (or <strong>quiet</strong>) State: the state when the latch is storing a value, either <code>0</code> or <code>1</code> and nothing is try to change the value.</li><li>When inputs <em><strong>S</strong></em> and <em><strong>R</strong></em> both have logic value <code>1</code>.</li><li>At this time, the output of <em><strong>a</strong></em> and <em><strong>b</strong></em> won’t change. (But <em><strong>a</strong></em> and <em><strong>b</strong></em> are the opposite if we set <em><strong>S</strong></em> and <em><strong>R</strong></em> properly.)</li><li><strong>Setting</strong> the Latch to <em><strong>a</strong></em> <code>1</code> or <em><strong>a</strong></em> <code>0</code></li><li>The latch can be set to <em><strong>a</strong></em> <code>1</code> by momentarily setting <em><strong>S</strong></em> to <code>0</code>.</li><li>The latch can be set to <em><strong>a</strong></em> <code>0</code> by momentarily setting <em><strong>R</strong></em> to <code>0</code>.</li><li>Both <em><strong>S</strong></em> and <em><strong>R</strong></em> must never be allowed to be set to <code>0</code> at the <strong>same time</strong>.</li></ul><h2 id="The-Gated-D-Latch"><a href="#The-Gated-D-Latch" class="headerlink" title="The Gated D Latch"></a>The Gated D Latch</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2014.png" alt="Untitled"></p><p>WE stands for write enable.When it is not asserted, the output S and R are both equal to 1. When it is momentarily set to 1,exactly one of the outputs(S or R) are set to 0,depending on the values of D.</p><p>D&#x3D;1—&gt;S&#x3D;0     D&#x3D;0—&gt;R&#x3D;0    WE&#x3D;0—&gt;S&#x3D;R&#x3D;1</p><h1 id="The-Concept-of-Memory"><a href="#The-Concept-of-Memory" class="headerlink" title="The Concept of Memory"></a>The Concept of Memory</h1><p>Memory is made up of a number of locations, each uniquely identifiable and each having the ability to store a value.We refer to the unique identifier associated with each memory location as its address. And the number of bits of information stored in each location as its addressability.</p><ul><li>Address Space : the total number of uniquely identifiable locations.</li><li>Addressability : 注意和 address space 做区分，address space 指的是 memory 中，依据寻址输入（下图的<code>A[1:0]</code>）能够查询到的 location 数量的<strong>上限</strong>（即两条线但是只画出了 3个location的话，address space 依然是 4）。</li><li>A 2^2-by-3-Bit Memory</li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2015.png" alt="Untitled"></p><p>▪ 左侧的 decoder 解析<code>A[1:0]</code>中传入的 location 信息，然后将该信息输入到 mux 中，以选择路由对应的 location 信息。</p><p>▪ That is, the memory has an <strong>address space</strong> of four locations and an <strong>addressability</strong> of three bits. It requires two bits to specify the address.</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2016.png" alt="Untitled"></p><h1 id="Sequential-Logic-Circuits"><a href="#Sequential-Logic-Circuits" class="headerlink" title="Sequential Logic Circuits"></a>Sequential Logic Circuits</h1><ul><li>Can both <strong>process</strong> information and <strong>store</strong> information.</li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2017.png" alt="Untitled"></p><ul><li>Sequential logic circuits are used to implement a very important class of mechanisms called <strong>finite state machines</strong>, which are used in essentially all branches of engineering.</li><li>e.g: used as controllers of electrical systems, mechanical systems, and aeronautical systems.</li></ul><h2 id="An-Example-The-Combination-Lock"><a href="#An-Example-The-Combination-Lock" class="headerlink" title="An Example: The Combination Lock"></a>An Example: The Combination Lock</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2018.png" alt="Untitled"></p><ul><li>Lock (a) will only open when you complete dialing in a specific order. Assume that the correct order is R13-L22-R3.</li><li>Lock (b) won’t care about how you complete rotation.</li></ul><h2 id="The-Concept-of-State"><a href="#The-Concept-of-State" class="headerlink" title="The Concept of State"></a>The Concept of State</h2><p>State: is a snapshot of all the relavent elements of the system at the moment the snapshot is taken.</p><ul><li>A finite state machine consists of five elements:</li></ul><ol><li>a finite number of states;</li><li>a finite number of external inputs ;</li><li>a finite number of external outputs;</li><li>an explicit specification of all state transitions;</li><li>an explicit specification of what determines each external output value;</li></ol><ul><li>There is no fixed amount of time between successive inputs to the finite stat machine above. We say these systems are <strong>asynchronous</strong> because there is nothing synchronizing when each state transition must occur.</li><li>Synchronous Finite State Machine: the state transitions take place, one after the other, at identical fixed units of time.</li></ul><p>Attention: Whether it is synchronous or not,they carry out work,one state transition at a time, moving closer to a goal.</p><ul><li>The Clock: Control of that synchronous behavior is in part the responsibility of the clock circuit. Each of the repeated sequence of identical intervals is referred to as a <strong>clock cycle.</strong></li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2019.png" alt="Untitled"></p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2020.png" alt="Untitled"></p><h2 id="The-Flip-Flop"><a href="#The-Flip-Flop" class="headerlink" title="The Flip-Flop"></a>The Flip-Flop</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2021.png" alt="Untitled"></p><p>▪ The storage elements that allow us to read the current state throughout the current clock cycle, and <strong>not</strong> write the next state values into the storage elements <strong>until</strong> the beginning of the next clock cycle.</p><ul><li>Reading must be allowed throughout the clock cycle, and writing must occur at the end of the clock cycle.</li><li>The master &#x2F; slave flip-flop can be constructed out of <strong>two gated D latches</strong>, one referred to as the <strong>master</strong>, the other referred to as the <strong>slave</strong>.</li><li>Think about that: When <em>master</em> is “reading”, the <em>slave</em> is “writing”, and vice versa.</li><li>FF 的行为在一个 Clock Cycle 里完成，在分析不同维度的事情的时候要从不同维度的角度来思考。</li><li>更底层的：</li><li>假设 Cycle 的前半部分 Master 可写， Slave 只读，则：</li><li>在模式切换的那一瞬间，Master 写入的数据会被 Slave 存储；</li><li>更抽象的：</li><li>在 Cycle 开始结束后，会输出 Cycle 进行时输出的数据；</li></ul><h1 id="The-Preview-of-Datapath-in-LC-3"><a href="#The-Preview-of-Datapath-in-LC-3" class="headerlink" title="The Preview of Datapath in LC-3"></a>The Preview of Datapath in LC-3</h1><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2022.png" alt="Untitled"></p><ul><li>The data path consists of all the logic structures that combine to process information in the core of the computer.</li><li>A <strong>register</strong> is simply a set of <em>n</em> flip-flops that collectively are used to store one <em>n</em> bit value.</li><li>In the figure, <strong>PC, IR, MAR,</strong> and <strong>MDR</strong> are all 16-bit <strong>registers</strong> that store 16 bits of information each. The block labeled <strong>REG</strong> <strong>FILE</strong> consists of <strong>eight registers</strong> that each store 16 bits of information.</li><li>The data path also shows three <strong>1-bit registers</strong>, <strong>N, Z,</strong> and <strong>P</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 2</title>
      <link href="/2023/11/03/review-chap-2-44ab637553b3440d9a08155cb4dc336a/"/>
      <url>/2023/11/03/review-chap-2-44ab637553b3440d9a08155cb4dc336a/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-2"><a href="#Review-Chap-2" class="headerlink" title="Review Chap 2"></a>Review Chap 2</h1><ul><li><p>Bits: We represent the presence of voltages as “1” and the absence of a voltage as “0”. We refer to each 0 and each 1 as a “bit”, which is shortened from binary digit.</p></li><li><p>Precisely, the electronic circuits in the computer differentiate voltages close to 0 from voltages far from 0.</p></li><li><p>With <em>k</em> bits, we can distinguish 2^k distinct items at most.</p></li><li><p>Data Types: 1. 2’s complement integers for representing positive and negative integers that we wish to perform arithmetic on, 2. ASCII codes for representing characters that we wish to input to a computer via the keyboard or output from the computer via a monitor(These are two data types which will be used in following chapters)</p></li><li><p>Integer data types</p><ol><li>Unsigned Integers.（我寻思着这玩意我还是会的）with k bits,we can represent 2^k integers,ranging from 0 to 2^k -1.</li><li>Signed Integers. （用中文）正数以0为先导，负数以1为先导，with k bits,we can represent 2^k -1 integers,ranging from - 2^（k -1）-1 to 2^（k -1）-1. 但是出现了-0（如在五位当中，10000表示-0而00000表示0，这就尴尬了）</li><li>1’s complement integers（反码，似乎不重要）</li><li>2’s complement integers （补码，很重要，一会展开讲）</li></ol><p>  <img src="/Review%20Chap%202%2044ab637553b3440d9a08155cb4dc336a/Untitled.png" alt="Untitled">  </p></li><li><p>关于补码的引入，书中从底层实现的角度给出了解释，进行归纳的话我认为主要是这两个因素：① 2’s complement 中“溢出”与“取模”的关系；② ALU 模块只进行加法运算，而不能进行减法运算；（需要注意的是，所谓的符号位是给人看的，或者说只是一个特征。在实际过程中并不存在“符号位”，即该位也参与加法计算）</p></li></ul><aside>💡 ALU : arithmetic and logic unit, which is very important in future study.</aside><p>我觉得二进制加法我还不至于不会，这里省了。</p><ul><li><p>Conversion  Binary to Decimal</p><ol><li>examine the leading bit b7 to determine whether it is positive or negative.If it is negative, do step 2 after flipping all the bits and adding 1.</li><li>then simply: b6 *2^6+b5 *2^5+…+b0 *2^0</li><li>get the result, then if it is negative, don’t forget the minus sign.</li></ol></li><li><p>Conversion Decimal to Binary</p><ol><li>obtain the binary representation of the magnitude of N by forming the equation N&#x3D;b6⋅2^6+b5⋅2^5+…+b0⋅2^0.  and repeating and following,until the left side of the equation is 0: a.If N is odd,the rightmost bit is 1.If N is even,the rightmost bit is 0.<br>  b.Subtract 1 or 0(according to whether N is odd or even)from N,remove<br>  the least signiﬁcant term from the right side,and divide both side sof<br>  the equation by 2.</li><li>if it is positive, add a leading 0 then finished.</li><li>if it is negative, add a leading 0 and then form the negative of this 2’s complement representation, and then you are done.</li></ol></li><li><p>Specially for floating point data type</p><ul><li>1 bit for the sign (positive or negative)</li><li>8 bits for the range (the exponent field)</li><li>23 bits for precision (the fraction field)  数据部分，但是组织形式有一些微妙，“第一位”是<code>0</code>还是<code>1</code>有特殊的处理方式</li></ul><p>  <img src="/Review%20Chap%202%2044ab637553b3440d9a08155cb4dc336a/Untitled%201.png" alt="Untitled"></p>  <aside>  💡 The 32-bit floating point data type    </aside>  <ul><li><p>They are mostly in normalized form: (不需要考虑补码）</p><p>  <img src="https://cdn.nlark.com/yuque/__latex/037c64c8fbf18f1fa3486b7f549ebb4b.svg" alt="https://cdn.nlark.com/yuque/__latex/037c64c8fbf18f1fa3486b7f549ebb4b.svg"></p></li></ul></li><li><p>exponent&#x3D;00000000——subnormal numbers</p></li><li><p>exponent&#x3D;11111111——infinity</p></li><li><p>Sign-extension (<strong>SEXT</strong>)</p></li><li><p>The value of a <strong>positive number</strong> does <strong>not change</strong> if we <strong>extend</strong> the sign bit <strong>0</strong> as many bit positions <strong>to the left</strong> as desired. Similarly, the value of a <strong>negative number</strong> does <strong>not change</strong> by <strong>extending</strong> the sign bit <strong>1</strong> as many bit positions <strong>to the left</strong> as desired.</p></li><li><p>也就是说按照符号位向高位扩展，且这种扩展是不会影响原来的值的。</p></li><li><p>Overflow</p></li><li><p>最高位（比如符号位）进位后不会创建一个更高位来存储这个进位信息，而是直接丢弃这个进位，也就是“溢出”，在数学层面来看，就类似于取模，比如，对应<code>1110</code> + <code>1001</code> &#x3D; <code>~~1~~0111</code>。</p><p>  <img src="https://cdn.nlark.com/yuque/__latex/5b8307da33e4ddcbecd7ca8925c4aaca.svg" alt="https://cdn.nlark.com/yuque/__latex/5b8307da33e4ddcbecd7ca8925c4aaca.svg"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023</title>
      <link href="/2023/11/02/ics-2023-88cec008ce4942edba428dc0868292e0/"/>
      <url>/2023/11/02/ics-2023-88cec008ce4942edba428dc0868292e0/</url>
      
        <content type="html"><![CDATA[<h1 id="ICS-2023"><a href="#ICS-2023" class="headerlink" title="ICS 2023"></a>ICS 2023</h1><p>2023年7月12日-28日 授课老师：Yale Patt Jxh<br>Patt上课还是很值得一听的（前提是你跟得上），jxh就比较一言难尽，2023年貌似是patt最后一年来中国了，以后这课有没有还两说。<br>这份笔记是我暑假回了德州在图书馆补天的作品，借鉴了很多别人的智慧结晶，所以我还是那个菜鸡罢了。<br>各位凑合看吧。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> 计算机系统概论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>榜上留名之后</title>
      <link href="/2023/10/15/after-successful/"/>
      <url>/2023/10/15/after-successful/</url>
      
        <content type="html"><![CDATA[<h1 id="A-blog-written-in-2023-10"><a href="#A-blog-written-in-2023-10" class="headerlink" title="A blog written in 2023.10"></a>A blog written in 2023.10</h1><p>正在疯狂憋OOP的代码，突然耳机当中的歌又一次切到了Wherever You Will Go，The Calling乐队的歌。  </p><p>我喜欢The Calling和它的主唱Alex Band的几乎所有歌曲，这首歌我更是在社交平台分享过不止一次。但最近几次听这首歌，我却有了一些游离于歌词之外的感受，考虑到OOP的ddl还早，我决定先把它搁置一边，开始写点不一样的东西。  </p><p>这是一首什么歌？这是一首虽然在国内热度一般，但是却在YouTube和Spotify收获上亿听众的歌曲；这是一首把一个本来默默无闻的普通乐队一下子推上顶流的歌曲；这也是一首能打动人心引起共鸣的歌曲，Originally Performed by The Calling.  </p><p>但是，可悲的是，如今的The Calling和Alex Band，只剩下这么一首能被人记住的歌曲了，一首Alex在16岁时就写出来，20岁发行的歌曲，而如今，20多年过去了，他们却只剩下这么一首勉强算得上流行的歌曲，完美诠释One hit wonder。  </p><p>这怪Alex和他当时的团队吗？我觉得显然不是，无数的欧美歌手都面临过这种问题，one hit wonder 甚至 two hit wonder，即所谓”昙花一现“，例如，Daniel Powter只有Bad Day和Free Loop两首拿得出手的歌曲，3 Doors Down 只有一首《Here Without You》能够被人记住，James Blunt唱了这么多年歌，也只有一首《You’re Beautiful》大红大紫，这个问题甚至让他在日后推出的一首《2005》专门吐槽“只火一首歌”带给他的不满……      </p><p>也是，不是人人都是周杰伦，Taylor Swift或者Ed Sheeran。“只火一首歌”总比什么成就都没有强，而强中最强是很难达到的，有些时候，出名成功过那么一次，就足够普通人Dreaming in Red了。  </p><p>于是又想到我自己。  </p><p>我本来就是一个不对自己有过高要求的人，也是把握住了一次重要的机会（高考），到达了目前我所在的位置，但是在这个环境里面我又越发感觉到自己的平凡，与其他人的差距之大，我大概知道我很难成为周杰伦之类的常青树了，不过，我也不太想成为Alex。  </p><p>之前翻看ins和推特，发现Alex Band现在无论是颜值还是唱功都大不如前，之前那份俊朗的面容和独一无二的浓重嗓音变成了憔悴枯槁的形容和极易破音的嗓子。尽管如此，他的主页上依然用醒目的字体告诉所有人：他是Wherever You Will Go的原唱。他在16岁的灵光一现，成为了他整个人生中的最大闪光点。  </p><p>那么，我18岁时候的灵光一现，会成为我以后人生中最值得一提的东西吗？  </p><p>我不希望如此，未来如何，我拭目以待。  </p><p>10.15写于紫金港基图一楼  </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大学第一年对自己的一些总结（2023.07）</title>
      <link href="/2023/07/02/first-year-summary/"/>
      <url>/2023/07/02/first-year-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="大学第一年对自己的一些总结（2023-07）"><a href="#大学第一年对自己的一些总结（2023-07）" class="headerlink" title="大学第一年对自己的一些总结（2023.07）"></a>大学第一年对自己的一些总结（2023.07）</h1><p>大学的第一个学年，随着今天下午最后一门课的出分而宣告结束。虽然我暑假还有一门短学期课要上到七月底，不过那已经属于是下个学年的课了。<br>所以说我就有时间思考一下大一这一年，我干了什么，收获了什么，失去了什么。<br>我记得我第一天来到求是园的场景，从东二门进去，跟我爸和我哥说再见，拖着行李上了接驳车，下车，走进宿舍，整个的过程中，我全程注视着窗外或者看着四周，看着这个我高中三年从来没有想过能够考上的学校。<br>然后我进了寝室，掏钥匙，开寝室门，当水泥地面和简陋的上下铺映入眼帘之时，我脱口而出的是“操”。<br>合着我进了浙大说的第一个字是个脏字。<br>不过很快我就接受了住宿条件，和舍友熟络，认识新的班集体，然后是军训。<br>军训的过程我就不细说了，我的记忆也比较模糊，只记得最后拿了个3.9，正当我觉得还行的时候，一刷朵朵，发现还有人正因为军训没满绩而闷闷不乐，我瞬间就不淡定了。<br>我开始第一波初步焦虑，看着周围的人个个都像卷王；不过很快就停止了：我发现至少在微积分这一门课上，比我菜的人还是大有人在的，我大可不必这么卑微，这么焦虑。学好了，那就好；学差了，我也不是最差；就算我是最差的那个，那也只能说明我有充足的上升空间。再说了，当倒数几名对我又不是新鲜事，高中我也不是没当过。<br>上学期的生活细节早就记不清了，就记得一些记忆碎片：比如东三的核酸检测，比如线性代数期中不及格，比如在北教和足协的同志们看世界杯，比如被拉去桐庐隔离，等等。然后在12月10号的四级考试以后，我迅速润回德州。<br>考试延后，寒假我不说是卷了，至少也能说是认真学了，大一上学期的GPA好歹有个4.2吧。<br>到了大一下，我踌躇满志爆选30+学分，选的课也有大英五这样听名就让人闻风丧胆的课。然后就在我以为一切尽在掌握之中的时候，一切就不出意外地出意外了。<br>一门程序设计课，队友不给力，原本确定的选题任务未能在规定时间内完成，我反倒是在规定时间内精神状态崩溃，上课也不去上，作业也写不动，甚至都想重开了，在一周多的时间里，我不仅一行代码都敲不动，其他课也学不进去，这就让我本就薄弱的基础课雪上加霜。<br>这就是我第二波焦虑开始的时候：看着我认识的人一个个成绩突飞猛进得心应手，甚至有时间搞起了ACM种种，我却被一个简单的程序设计课困住动弹不得，甚至濒临挂科，我对自己的怀疑和卑微感又上升了一个档次，看着学院发的院衫，我一度怀疑我配不配把它穿在身上。<br>考试周结束，我看着我的GPA慢慢下降，最后稳定在一个低的不能再低的数字，我突然释怀了。<br>大学生活又不是只有GPA，我大可以在别的地方证明自己配得上当浙大人，配得上计院。学习不是一切，社团活动、体育锻炼、感情生活，每一个都可以过得很充实，都可以丰富生活。<br>所以说，大学一年，我收获了什么？<br>我收获了知识，毫无疑问，虽然掌握程度和其他人亦有差距；收获了朋友，很多朋友；收获了经验，无论是转播足球比赛的经验还是一个人三天solo一个大程序+实验报告的经验，都是好的。<br>唯一美中不足的是没有收获爱情（bushi）。<br>我接下来要干什么？<br>GPA不是全部，我只想好好过完大学后面三年，底线是学到东西并且不挂科，上限那我也不知道。<br>怎么形容我理想中的大学生活？快乐？不准确，充实？也不准确。反倒是我那个充满了戏谑色彩的微信昵称能形容我的预想：准时不早退。<br>准时到达大学生活的每一个重要节点，不草草退场，不崩溃断线，够了，我只求准时不早退。<br>Eddie<br>7月3日晚写于浙江大学紫金港校区碧峰</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大学生活 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎页</title>
      <link href="/2023/01/01/first-blog/"/>
      <url>/2023/01/01/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="First-Time-Using-Hexo"><a href="#First-Time-Using-Hexo" class="headerlink" title="First Time Using Hexo"></a>First Time Using Hexo</h1><p>It’s a good thing to put something here.<br>了解我的人大概知道我是有一定的表达欲望的，所以个人网站给了我一个很好的机会去多啰嗦两句，nice。<br>这是另一个欢迎页，欢迎你们随时来看看我能搞出点什么名堂，不过不要对我有非常大的期望。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Welcome </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
