<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>çœ‹çƒæ—¥è®°1ï¼šåŒçº¢ä¼š</title>
      <link href="/2024/04/08/kq/"/>
      <url>/2024/04/08/kq/</url>
      
        <content type="html"><![CDATA[<h1 id="çœ‹çƒæ—¥è®°1ï¼šåŒçº¢ä¼š-2024-04-08"><a href="#çœ‹çƒæ—¥è®°1ï¼šåŒçº¢ä¼š-2024-04-08" class="headerlink" title="çœ‹çƒæ—¥è®°1ï¼šåŒçº¢ä¼š 2024 04 08"></a>çœ‹çƒæ—¥è®°1ï¼šåŒçº¢ä¼š 2024 04 08</h1><p>ï¼ˆå†™åœ¨å‰é¢ï¼šæœ¬æ¥æƒ³ç»™f1æ—¥æœ¬ç«™ä¹Ÿå†™ä¸€ä¸ªè§‚èµ›è®°å½•çš„ï¼Œä½†æ˜¯å®åœ¨æ˜¯å¤ªæ— èŠäº†ï¼ï¼ç­‰ä»€ä¹ˆæ—¶å€™æ½˜å­ä¸æ‹¿å† å†›äº†æˆ‘å†å†™ï¼‰  </p><p>è¿™åœºåŒçº¢ä¼šï¼Œæ¯”åˆ†2ï¼š2ï¼Œæ›¼è”çƒè¿·å¯¹è¿‡ç¨‹ä¸æ»¡æ„ï¼Œåˆ©ç‰©æµ¦çƒè¿·å¯¹ç»“æœä¸æ»¡æ„ã€‚<br>èµ›å‰æˆ‘èˆå‹é—®æˆ‘å¯¹ç»“æœé¢„æµ‹å¦‚ä½•ï¼Œæˆ‘ç›´æ¥ä»¥æˆ‘äºŒåå¹´æ›¼è”çƒè¿·çš„ç›´è§‰é¢„æµ‹è¯´æ›¼è”ä¸å¯èƒ½èµ¢ï¼›è·ŸæŸèµ„æ·±åˆ©ç‰©æµ¦çƒè¿·èŠå¤©ï¼Œä»–æŒ‡å‡ºäº†è¿™åœºæ¯”èµ›å¯¹äºåˆ©ç‰©æµ¦çš„é‡è¦æ€§ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸èµ¢ä¸è¡Œã€‚æˆ‘å¯¹æ›¼è”ä¸€å¼€å§‹çš„æœŸæœ›æ˜¯è‹Ÿä½å¹³å±€ï¼Œçœ‹å®Œä¼¤å…µåå•å’Œé¦–å‘é˜µå®¹ä»¥åæˆ‘ä»”ç»†ä¸€æƒ³ï¼Œå°±è¿™å¥—é˜µå®¹ï¼Œå®ˆä¹Ÿå®ˆä¸ä½ï¼Œä¸å¦‚è·Ÿåˆ©ç‰©æµ¦çˆ†äº†ã€‚<br>ä¸ŠåŠåœºæœç„¶åœ¨æˆ‘çš„é¢„æƒ³ä¹‹ä¸­ï¼Œé™¤äº†ä¸€å¼€åœºåŠ çº³ä¹”é‚£ä¸ªè¶Šä½çƒç»™æˆ‘å…´å¥‹äº†ä¸€ä¸‹ä¹‹å¤–ï¼Œæ•´ä¸ªä¸ŠåŠåœºåˆ©ç‰©æµ¦éƒ½æ˜¯æŒ‰ç€æ›¼è”æï¼Œæ›¼è”ä¸ŠåŠåœº0å°„é—¨ä¹Ÿè¯´æ˜äº†å¾ˆå¤§çš„é—®é¢˜ï¼Œè¦ä¸æ˜¯è¨æ‹‰èµ«å’Œå¥¥çº³çº³ï¼Œä¸ŠåŠåœºä¼°è®¡å°±èŠ±äº†ã€‚<br>ä½†æ­£å½“æˆ‘ä»¥ä¸ºå¤§å±€å·²å®šå‡†å¤‡ä¸ŠåºŠç¡è§‰çš„æ—¶å€™ï¼Œè®©æˆ‘ä¸‡ä¸‡æ²¡æƒ³åˆ°çš„äº‹æƒ…å‘ç”Ÿäº†ï¼Œåˆ©ç‰©æµ¦çš„å°å°†åå«å¤±è¯¯é€äº†bè´¹ä¸€ä¸ªå‡ ä¹æ˜¯åŠå°„ç©ºé—¨çš„æœºä¼šï¼Œæ›¼è”å°±å€Ÿç€è¿™ä¸ªçƒ1ï¼š1æ‰³å¹³äº†æ¯”åˆ†ã€‚<br>çœ‹åˆ°è¿™æˆ‘å°±ç²¾ç¥äº†ï¼Œä¸€ä¸‹å­ä»åºŠä¸Šå¼¹èµ·æ¥æ¥ç€çœ‹ç›´æ’­ï¼Œç„¶åå‘ç°æ›¼è”æœç„¶èµ·åŠ¿äº†ï¼Œå¯ä»¥è¯´æ²¡æœ‰å¤¸å®‰è¨è¿™ä¸€æ³¢å¤±è¯¯ï¼Œæ›¼è”è¿™åœºå¯èƒ½çœŸå°±ç©å®Œäº†ã€‚<br>ç„¶åå°±æ˜¯ç§‘æ¯”æ¢…åŠªäº†ï¼Œä¸€æ‹›åä»°å°„é—¨ç›´æ¥æ‰“è¿›ä¸Šè§’ï¼Œåˆ©ç‰©æµ¦çš„æµªè´¹æœºä¼šä»¥åŠä¼¼ä¹èƒ½çœ‹å‡ºæ¥çš„è½»æ•Œï¼ˆå­˜ç–‘ï¼‰æœ€ç»ˆä½¿ä»–ä»¬ä»˜å‡ºäº†ä»£ä»·ï¼Œåœ¨è¿™ä¹ˆå¤šè¿åŠ¨æˆ˜å°„é—¨çš„æƒ…å†µä¸‹ï¼Œæœ€ç»ˆå´è¿˜è¦é å®šä½çƒå’Œç‚¹çƒä¸æ›¼è”å ªå ªæ‰“å¹³ï¼Œè¿™ç»å¯¹ä¸æ˜¯ä»–ä»¬å€¼å¾—éª„å‚²çš„äº‹æƒ…ã€‚<br>æœ€åç®€è¯„ä¸‹æ›¼è”è¿™è¾¹ï¼Œè¡¨ç°æ€»ä½“æ¥è¯´æ˜¯éƒ½å¯ä»¥æ¥å—çš„ï¼Œå¥¥çº³çº³æ¢…åŠªåå¸ƒç“¦æ‹‰è‡ªç„¶ä¸ç”¨å¤šè¯´ï¼Œä¸¤ä¸ªè¾¹åå«è™½ç„¶éƒ½æœ‰å¤±è¯¯ï¼Œä½†æ€»ä½“ä¸Šä¸‡æ¯”è¨å¡åŠŸè¿‡ç›¸æŠµï¼Œè¾¾æ´›ç‰¹åŠŸå¤§äºè¿‡ï¼›æ‹‰ä»€ç¦å¾·è¿™åœºèƒ½çœ‹å‡ºæ¥æœ‰ç‚¹æ‹¼ï¼Œè‡³å°‘æ¯”å‰å‡ åœºçº¯åœ¨æ‘†çƒ‚å¼ºï¼›éœä¼Šä¼¦ä¸­è§„ä¸­çŸ©ï¼›bè´¹æˆ‘ä¸ŠåŠåœºä¸€ç›´åœ¨éª‚ï¼Œä½†é‚£ä¸ªè¿›çƒå¾ˆå…³é”®ï¼Œå¯ä»¥æŠ¹å»ä»–çš„å¤§éƒ¨åˆ†æŠ½è±¡ï¼›å¡å¡ç±³ç½—è€äº†ï¼Œä½†æ˜¯å°šèƒ½ä¸€æˆ˜ï¼›åŠ çº³ä¹”å¤Ÿæ‹¼ï¼›æ›¿è¡¥é‚£å‡ ä½é™¤äº†é˜¿å§†æ‹‰å·´ç‰¹ä¹Ÿéƒ½ä¸é”™äº†ï¼Œæ€»ä½“ä¸Šçœ‹æ›¼è”è¿™åœºçš„è¡¨ç°é—®é¢˜æ²¡é‚£ä¹ˆå¤§ï¼Œè€Œä¸”æ›¼è”ä¹Ÿå¹¶æ²¡æœ‰é¾Ÿç¼©è€Œæ˜¯å‡ºæ¥å‹è¿«ï¼Œè™½ç„¶ä¸­åœºåˆè·Ÿä¸ªå¤§é©¬è·¯ä¸€æ ·ï¼Œä½†è‡³å°‘ä½“ç°å‡ºæ¥äº†è…¾å“ˆæ ¼â€œå‹‡çŒ›â€çš„ä¸€é¢ã€‚<br>è¿™èµ›å­£çš„æ›¼è”æŠ½è±¡åˆ°ä¸€å®šç¨‹åº¦äº†ï¼Œæ— è®ºæ˜¯è¿œçš„å»å¹´æ¬§å† ï¼Œè¿˜æ˜¯è¿‘çš„ä¸Šåœºè¸¢åˆ‡å°”è¥¿ï¼Œéƒ½è®©æˆ‘ä¸å¿ç›´è§†ï¼Œä½†å¥½å¤„æ˜¯æ›¼è”æ‰“ç¡¬ä»—çš„é‚£è‚¡åŠ²ä¸€ç›´æ²¡ä¸¢ï¼Œè¿™ä¾æ—§æ˜¯å€¼å¾—é¼“åŠ±çš„ã€‚ä½†ä½œä¸ºçƒè¿·ï¼Œæˆ‘èƒ½åšçš„ææ€•åªæœ‰ç»§ç»­ç­‰å¾…æ›¼è”çš„å¤å…´äº†â€¦â€¦<br>Eddie 2024.04.08 15:00 pm</p>]]></content>
      
      
      
        <tags>
            
            <tag> çœ‹çƒ </tag>
            
            <tag> æ—¥è®° </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Appendix C</title>
      <link href="/2023/12/03/review-appendix-c-cd9a0ed5b3cf4315b26d30684db02354/"/>
      <url>/2023/12/03/review-appendix-c-cd9a0ed5b3cf4315b26d30684db02354/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Appendix-C"><a href="#Review-Appendix-C" class="headerlink" title="Review Appendix C"></a>Review Appendix C</h1><p>éƒ½è¯´Appendix Aå’ŒCæ˜¯å…¨ä¹¦ç²¾åä¹‹ç²¾åï¼Œé‚£è¿˜æ˜¯è¦æŠŠAppendix Cæ¶ˆåŒ–æ¶ˆåŒ–çš„ï¼Œäº‰å–æ­£å¼å¼€å­¦ä¹‹å‰çœ‹å®Œå®ƒã€‚</p><p>Two main component of a microachitecture: the data path, which contains all the components that actually process the instructions, and the control, which contains all the components that generate the set of control signals that are needed to control processing at each clock cycle.</p><p><img src="/Review%20Appendix%20C%20cd9a0ed5b3cf4315b26d30684db02354/Untitled.png" alt="Untitled"></p><p><img src="/Review%20Appendix%20C%20cd9a0ed5b3cf4315b26d30684db02354/Untitled%201.png" alt="Untitled"></p><p><img src="/Review%20Appendix%20C%20cd9a0ed5b3cf4315b26d30684db02354/Untitled%202.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 1</title>
      <link href="/2023/12/02/ics-2023-review-chap-1-2f9e9fc7a6224dbcb7db7a95853e3bcf/"/>
      <url>/2023/12/02/ics-2023-review-chap-1-2f9e9fc7a6224dbcb7db7a95853e3bcf/</url>
      
        <content type="html"><![CDATA[<h1 id="ICS-2023-Review-Chap-1"><a href="#ICS-2023-Review-Chap-1" class="headerlink" title="ICS 2023 Review Chap 1"></a>ICS 2023 Review Chap 1</h1><ul><li>1.abstraction: a technique for establishing a simpler way for a person to interact with a system, removing the details that are unnecessary for the person to interact effectively with the system. We all need the ability to abstract. Hardware and software: we need to know both of them, instead of seperating them.</li><li>A computer system generally includes, in addition to the processor, a keyboard for typing commands, a mouse or keypad or joystick for positioning on menu entries, a monitor for displaying information that the computer system has produced, memory for temporarily storingv information, disks and USB memory sticks of one sort or another forstoring information for a very long time, even after the computer has been turned oï¬€,connections to other devices such as a printer<br> for obtaining paper copies of that information, and the collection of programs(the software) that the user wishes to execute.</li><li>Two important ideas:ï¼ˆ1ï¼‰All computers are capable of computing exactly the same things if they are given enough time and enough memory. The only difference is the time.(2) (in Chinese) è®¡ç®—æœºæ— æ³•ç›´æ¥é¢†æ‚Ÿè‡ªç„¶è¯­è¨€ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ç”¨ä¸€ç§è®¡ç®—æœºèƒ½å¤Ÿæ‰§è¡Œçš„è¯­è¨€å»æŒ‡å¯¼è®¡ç®—æœºè§£å†³é—®é¢˜ã€‚</li><li>Before modern digital computers, the most common digital machines in the West were <em>adding machines</em> that can add integers. In other parts of the world another digital machine, the abacus, was common. The main limitation of all these machines is that they could do only one specific kind of computation.</li><li>This is why computers are different. You can tell a computer how to add numbers. You can tell it how to multiply. You can tell it how to alphabetize a list or perform any computation you like. When you think of a new kind of computation, you do not have to buy or design a new computer. You just give the old computer <strong>a new set of instructions</strong> (a program) to carry out the new computation. This is why we say the computer is a <strong>universal computational device</strong>. Computer scientists believe that <em>anything that can be computed</em>, can be computed by a computer provided it has enough time and enough memory. <em>When we study computers, we study the fundamentals of all computing.</em> We learn <strong>what computation is</strong> and <strong>what can be computed</strong>.</li><li>æ•™æåœ¨è¯¥ç« èŠ‚ä¹‹åçš„å†…å®¹æåˆ°äº†<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA">å›¾çµæœº</a>ï¼Œæˆ‘ä¸çŸ¥é“å¦‚ä½•ç”¨ç®€æ´çš„è¯­è¨€æç‚¼å†…æ¶µï¼Œæ‰€ä»¥æˆ‘å°±æ‘˜æŠ„æœ€æ ¸å¿ƒçš„è¿™ä¹ˆä¸€å¥è¯ï¼šâ€œOne way to try to construct a machine more powerful than any particular Turing machine was to make a machine U that could simulate all Turing machines.â€</li></ul><p><img src="/ICS%202023%20Review%20Chap%201%202f9e9fc7a6224dbcb7db7a95853e3bcf/Untitled.png" alt="Untitled"></p><aside>ğŸ’¡ æ³¨ï¼šä¼ªä»£ç å±äºproblems</aside><ul><li><p>Problems: described in natural language(e.g. English or Chinese), which are unacceptble for computers. One reason is the ambiguity.</p></li><li><p>Algorithms: We first need to transform the natural language description of a problem to algorithm. Here are the properties of the algorithm:</p></li><li><p>(1) <em>definiteness</em>. Each step is precisely stated. In Chinese we say ç¡®å®šæ€§, å³æ¯ä¸€æ­¥éƒ½æ˜¯ç¡®å®šçš„ï¼Œæ— æ­§ä¹‰çš„ã€‚</p></li><li><p>(2) <em>effective computability</em>. Each step can be carried out by a computer. å¯ç®—æ€§ï¼Œæ¯ä¸€æ­¥éƒ½èƒ½è¢«ç”µè„‘æ“ä½œè¿è¡Œã€‚</p></li><li><p>(3) <em>finiteness</em>. æœ‰é™æ€§ï¼Œ ä¹Ÿå°±æ˜¯è¯´ç®—æ³•æ˜¯å¯ä»¥ä¹Ÿç»ˆå°†ä¼šè¢«ä¸­æ­¢çš„ã€‚</p></li><li><p>Program: there are programming languages like C or C++. In fact there are more than 1,000 programming languages. We need to transform the algorithm into a  computer program using one of them. There are high-level and low-level languages. One representative low-level language is <em>assembly language</em>.</p><p>  <img src="/ICS%202023%20Review%20Chap%201%202f9e9fc7a6224dbcb7db7a95853e3bcf/Untitled%201.png" alt="Untitled"></p></li><li><p>ISA: it is the complete specification of the interface between programs that have been written and the underlying computer hardware that must carry out the work of those programs.</p></li><li><p>Sequence of 0s and 1s(the length is 16 in LC-3), which specifies the acceptable representations for operands and the mechanisms that the computer can use to figure out where the operands are located.</p></li><li><p>The number of opcodes,data types,and addressing modes specified by an ISA vary among different ISAs.</p></li><li><p>Microarchitecture (or <strong>implementation</strong>) is the <strong>digital logic</strong> that allows an instruction set to be executed. A microarchitecture is the <strong>physical implementation</strong> of an instruction set.</p></li><li><p>Each microarchitecture is an opportunity for computer designers to make different <strong>tradeoffs</strong> between the cost of the microprocessor, the performance that microprocessor will provide, and the energy that is required to power the microprocessor.</p></li></ul><p>(From ä¿®ä½¬ï¼‰å¾®æ¶æ„å’Œä¸Šé¢æåˆ°çš„æŒ‡ä»¤é›†æœ‰ç‚¹åƒâ€œç°å®ä¸è™šæ‹Ÿâ€äº¤ç•Œå¤„çš„ä¸¤ä¸ªå®ˆé—¨äººã€‚å¯¹äº ISA æ¥è¯´ï¼Œå¾®æ¶æ„æ˜¯å®ƒçš„ç”µè·¯å®ç°ï¼Œä½ å¯ä»¥æœ‰ä¸åŒçš„ç”µè·¯ï¼Œæ‹¿ä¸€ä¸ªæŒ‡ä»¤å¯¹åº”ä»€ä¹ˆäº‹æƒ…ï¼Œè¿™äº›æ˜¯ä¸èƒ½æ”¹å˜çš„ï¼Œæ‰€ä»¥è¯´ ISA å¯ä»¥å¯¹åº”å¤šä¸ªå¾®æ¶æ„ï¼Œä½†æ˜¯ä¸€ä¸ªå¾®æ¶æ„åªèƒ½å¯¹åº”ä¸€ä¸ª ISAã€‚</p><ul><li>Logic Circuit: letâ€™s talk about it in chapter 3.</li><li>Devices</li></ul>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Other Things You Need to Know to Pass the Exam</title>
      <link href="/2023/12/01/other-things-you-need-to-know-to-pass-the-exam-5d8b87e58f4949f4a863c2517980f023/"/>
      <url>/2023/12/01/other-things-you-need-to-know-to-pass-the-exam-5d8b87e58f4949f4a863c2517980f023/</url>
      
        <content type="html"><![CDATA[<h1 id="Other-Things-You-Need-to-Know-to-Pass-the-Exam"><a href="#Other-Things-You-Need-to-Know-to-Pass-the-Exam" class="headerlink" title="Other Things You Need to Know to Pass the Exam"></a>Other Things You Need to Know to Pass the Exam</h1><p>Control Unit and Processing Unit åˆç§°CPU</p><p>CCï¼šcondition codeä¹Ÿå°±æ˜¯çŠ¶æ€ç </p><p><code>TRAP</code>ï¼šä¸­æ–‡æ˜¯<strong>è‡ªé™·</strong>æˆ–<strong>è½¯ä¸­æ–­</strong>ï¼Œå…¶æœ¬è´¨ä¸ºç”¨æˆ·ç¨‹åºå‘OSç”³è¯·å¸®åŠ©ã€‚</p><p><img src="/Other%20Things%20You%20Need%20to%20Know%20to%20Pass%20the%20Exam%205d8b87e58f4949f4a863c2517980f023/Untitled.png" alt="Untitled"></p>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 9</title>
      <link href="/2023/11/28/review-chap-9-4e7fd7f41df64af38e6bea1c5827e4ec/"/>
      <url>/2023/11/28/review-chap-9-4e7fd7f41df64af38e6bea1c5827e4ec/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-9"><a href="#Review-Chap-9" class="headerlink" title="Review Chap 9"></a>Review Chap 9</h1><h3 id="Privilege-Priority-and-the-Memory-Address-Space"><a href="#Privilege-Priority-and-the-Memory-Address-Space" class="headerlink" title="Privilege,Priority, and the Memory Address Space"></a>Privilege,Priority, and the Memory Address Space</h3><p><strong>Privilege</strong>: it is about the right to do something, such as execute a particular instruction or access a particular memory location.(<strong>NOTE:</strong> not all computer programs have the right to execute all instructions.)</p><p>To make the system go correctly, we designate every computer system as either privileged or unprivileged. We often say supervisor privilege to indicate privileged. We say a program is executing in <strong>Supervisor</strong> mode to indicate <strong>privileged</strong>, or <strong>User</strong> mode to indicate <strong>unprivileged</strong>.</p><ul><li>If a program is executing in Supervisor mode, it can execute all instructions and access all of memory.</li><li>If a program is executing in User mode, it cannot.</li></ul><p><strong>Priority</strong>: it is about the urgency of a program to execute. This allows programs of greater urgency to interrupt programs of lesser urgency.</p><p><strong>Two Orthogonal Notions</strong></p><p>We said privilege and priority are two orthogonal notions, meaning they have nothing to do with each other.</p><p><strong>The Processor Status Register</strong></p><p>It contains the privilege and priority assigned to that program.</p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled.png" alt="Untitled"></p><p>Bit 15 specifies the privilege, where <strong>PSR[15]&#x3D;0 means supervisor privilege, and PSR[15]&#x3D;1 means unprivileged</strong>. Bits[10:8] specify the priority level of the program. The highest level is 7 and the lowest level is 0. Besides, it also contains the condition code.</p><p><strong>Organization of Memory</strong></p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%201.png" alt="Untitled"></p><ul><li>Locations x0000 to x2FFF are privileged memory locations. They contain the various data structures and code of the operating system. They require supervisor privilege to access. They are referred to as <strong>system space</strong>.</li><li><strong>Supervisor Stack</strong> is controlled by the operating system and requires <strong>supervisor</strong> privilege to access. It has a stack pointer called <strong>SSP</strong> (Supervisor Stack Pointer).</li><li>Locations x3000 to xFDFF are unprivileged memory locations. Supervisor privilege is not required to access these memory locations. All user programs and data use this region of memory. The region is often referred to as <strong>user space</strong>.</li><li><strong>User Stack</strong> is controlled by the user program and does <strong>not require privilege</strong> to access. It has a stack pointer called <strong>USP</strong> (User Stack Pointer).</li><li>Addresses xFE00 to xFFFF do not correspond to memory locations at all. That is, the last address of a memory location is xFDFF. Addresses xFE00 to xFFFF are used to identify registers that take part in input and output functions and some special registers associated with the processor.</li><li>PSR ~ xFFFC</li><li>processorâ€™s <strong>M</strong>aster <strong>C</strong>ontrol <strong>R</strong>egister (<strong>MCR</strong>)(clock cycle switch) ~ xFFFE</li><li><strong>KBSR</strong> <strong>KBDR</strong> <strong>DSR</strong> <strong>DDR</strong> â€¦</li><li>è¿™äº›å¹¶ä¸æ˜¯å®é™…å†…å­˜ï¼Œè€Œæ˜¯åˆ«æ˜ å°„è¿‡æ¥çš„ <strong>Memory-mapped I&#x2F;O</strong> ï¼</li><li>Since a program can only execute in <strong>Supervisor</strong> mode or <strong>User</strong> mode at any one time, only <strong>one</strong> of the two stacks is active at any one time.</li><li><strong>R6</strong> is generally used as the <strong>SP</strong> for the active stack. Two registers, <strong>Saved_SSP</strong> and <strong>Saved_USP</strong>, are provided to save the <strong>SP</strong> not in use. When privilege changes, for example, from <strong>Supervisor</strong> mode to <strong>User</strong> mode, the <strong>SP</strong> is stored in <strong>Saved_SSP</strong>, and the <strong>SP</strong> is loaded from <strong>Saved_USP</strong>.</li></ul><h3 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input&#x2F;Output"></a><strong>Input</strong>&#x2F;<strong>Output</strong></h3><ul><li>Even the simplest I&#x2F;O devices usually need at least <strong>two</strong> registers: one to hold the <strong>data</strong> being transferred between the device and the computer, and one to indicate <strong>status information</strong> about the device.</li><li>An example of status information is whether the device is <strong>available</strong> or is it still <strong>busy</strong> processing the most recent I&#x2F;O task.</li><li>Some Basic <strong>Characteristics</strong> of I&#x2F;O</li></ul><p><strong>Memory-Mapped I&#x2F;O</strong> vs. <strong>Special I&#x2F;O Instructions</strong></p><ul><li>The I&#x2F;O device registers are mapped to a set of addresses that are allocated to I&#x2F;O device registers rather than to memory locations. Hence the name <strong>memory-mapped I&#x2F;O</strong>.</li><li>Special I&#x2F;O Instructions are not so liked.</li></ul><p><strong>Asynchronous</strong> vs. <strong>Synchronous</strong></p><ul><li>Most I&#x2F;O is carried out at speeds very much <strong>slower</strong> than the speed of the processor.</li><li>The point is that I&#x2F;O devices usually operate at speeds very different from that of a microprocessor, and not in lockstep. We call this latter characteristic <strong>asynchronous</strong>. Most interaction between a processor and I&#x2F;O is asynchronous.</li><li>To control processing in an asynchronous world requires some <strong>protocol</strong> or <strong>handshaking mechanism</strong>. So it is with our keyboard and monitor.</li><li>In the case of the keyboard, we will need a one-bit status register, called a <strong>flag</strong>, to indicate if someone has or has not typed a character.</li><li>In the case of the monitor, we will need a one-bit status <strong>register</strong> to indicate whether or not the most recent character sent to the monitor has been displayed, and so the monitor can be given another character to display.</li><li>These flags are the simplest form of <strong>synchronization</strong>.</li><li>By examining the <strong>ready bit</strong> before reading a character, the computer can tell whether it has already read the last character typed.</li></ul><p><strong>Interrupt-Driven</strong> vs. <strong>Polling</strong></p><ul><li><a href="https://www.javatpoint.com/trap-vs-interrupt-in-operating-system">ğŸ”—</a> Difference between an interrupt and a trap.</li><li>The processor, which is computing, and the typist, who is typing, are two <strong>separate</strong> entities.</li><li>The issue of <strong>interrupt-driven</strong> vs. <strong>polling</strong> is the issue of who controls the interaction.</li><li><strong>Interrupt-driven</strong> acts like that the typist will tell the processor that there are some inputs.</li><li><strong>Polling</strong> acts like that the processor will interrogate typist again and again whether there have some inputs.</li><li>ä¸­æ–­æ˜¯æ¯å½“ç›‘æ§çš„è®¾å¤‡å‘ç”Ÿå˜åŒ–ï¼Œæ¯”å¦‚æœ‰è¾“å…¥çš„æ—¶å€™ï¼Œå°±æ‰§è¡Œä¸­æ–­ç›¸å…³çš„ä»£ç ç‰‡æ®µï¼›è€Œè½®è¯¢æ˜¯æŒ‡ä½ ä¸»åŠ¨å»ä¸æ–­è¯·æ±‚ï¼Œæ£€æµ‹ç›‘æ§çš„è®¾å¤‡æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚</li></ul><h3 id="Input-from-the-Keyboard"><a href="#Input-from-the-Keyboard" class="headerlink" title="Input from the Keyboard"></a>Input from the Keyboard</h3><p>Basic Input Registers (<strong>KBDR</strong> and <strong>KBSR</strong>): <strong>KBD</strong>ata<strong>R</strong> &amp; <strong>KBS</strong>tatus<strong>R</strong></p><ul><li>In the case of <strong>KBDR</strong>, bits [7:0] are used for the <strong>data</strong>, and bits [15:8] contain <strong><code>x00</code></strong>.</li><li>In the case of <strong>KBSR</strong>, bit [15] contains the synchronization mechanism, that is, the ready bit; and bit[14] is the interrupt enable bit, depending on whether or not the processor wants to give the I&#x2F;O device the right to <strong>request service</strong>.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202114753-8d54fc36-b428-4df3-9d29-c9dd39be0894.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202114753-8d54fc36-b428-4df3-9d29-c9dd39be0894.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>In LC-3, address <strong><code>xFE02</code></strong> is assigned to the <strong>KBDR</strong>; address <strong><code>xFE00</code></strong> is assigned to the <strong>KBSR</strong>.</li></ul><p>The Basic <strong>Input Service Routine</strong></p><ul><li>When type in something, <strong>KBDR</strong> is updated and <strong>KBSR</strong> is set to<code>1</code>. And <strong>KBDR</strong> canâ€™t be changed until <strong>KBSR</strong> is reset and the data in <strong>KBDR</strong> is read. So that each character can be loaded at least one time.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1663250915942-f266facd-a29d-4782-8ae5-45eef8dec8e4.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_12,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1663250915942-f266facd-a29d-4782-8ae5-45eef8dec8e4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202521661-df28eac7-1015-4b08-94dc-f6cf5d702098.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_27,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202521661-df28eac7-1015-4b08-94dc-f6cf5d702098.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Implementation of Memory-Mapped Input</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202840874-c88d4ccf-97ac-448a-9198-b5f86ffb8c53.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_35,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202840874-c88d4ccf-97ac-448a-9198-b5f86ffb8c53.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_35%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><h3 id="Output-to-the-Monitor-In-fact-very-similar-to-the-input"><a href="#Output-to-the-Monitor-In-fact-very-similar-to-the-input" class="headerlink" title="Output to the Monitor(In fact very similar to the input)"></a>Output to the Monitor(In fact very similar to the input)</h3><p>DDR and DSR replace KBDR and KBSR.</p><ul><li>In the case of <strong>DDR</strong>, bits [7:0] are used for data, and bits [15:8] contain <strong><code>x00</code></strong>.</li><li>In the case of <strong>DSR</strong>, bit [15] contains the synchronization mechanism, that is, the ready bit.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202935420-229bae47-be40-4e58-bb94-286e192a3cfb.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658202935420-229bae47-be40-4e58-bb94-286e192a3cfb.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>In LC-3, address <strong><code>xFE06</code></strong> is assigned to the <strong>DDR</strong>; address <strong><code>xFE04</code></strong> is assigned to the <strong>DSR</strong>.</li></ul><p>The Basic Output Service Routine</p><ul><li>When display something, <strong>DDR</strong> is updated and <strong>DSR</strong> is cleared. And <strong>DDR</strong> canâ€™t be changed until <strong>DSR</strong> is set to <code>1</code> and the data in <strong>DDR</strong> is printed.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203122513-1181fcb5-6e1f-4595-b41a-1a6c6b0159ff.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_32,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203122513-1181fcb5-6e1f-4595-b41a-1a6c6b0159ff.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_32%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p>Implementation of Memory-Mapped Output</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203253977-22ace587-a16b-48c9-a471-e64ff8c57ec8.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_36,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658203253977-22ace587-a16b-48c9-a471-e64ff8c57ec8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%202.png" alt="Untitled"></p><h3 id="Operating-System-Service-Routines-LC-3-Trap-Routines"><a href="#Operating-System-Service-Routines-LC-3-Trap-Routines" class="headerlink" title="Operating System Service Routines (LC-3 Trap Routines)"></a>Operating System Service Routines (LC-3 Trap Routines)</h3><ul><li>In general it is ill-advised to give user programmers access to these registers. That is why the addresses of hardware registers are part of the privileged memory address space and accessible only to programs that have supervisor privilege.</li><li>The simpler solution, as well as the safer solution to the problem of user programs requiring I&#x2F;O, involves the**<code>TRAP</code>** instruction and the operating system, which of course has supervisor privilege.</li><li>It (<strong><code>TRAP</code></strong>) allows the user programmer to not have to know the gory details of I&#x2F;O discussed earlier in this chapter. In addition, it protects user programs from the consequences of other inept user programmers.</li><li>The user program uses the <strong><code>TRAP</code></strong> instruction to request the operating system to perform the task on behalf of the user program. The operating system takes control of the computer, handles the request specified by the <strong><code>TRAP</code></strong> instruction, and then returns control back to the user program at location <code>x4001</code>. As we said at the start of this chapter, we usually refer to the request made by the user program as a <strong>system call</strong> or a <strong>service call</strong>.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658290174311-dc463c14-710d-49e8-8e28-5684c506a62e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658290174311-dc463c14-710d-49e8-8e28-5684c506a62e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><strong>The Trap Mechanism</strong></p><ul><li><strong>A set of service routines</strong> executed on behalf of user programs by the operating system. These are part of the operating system and start at arbitrary addresses in system space. The LC-3 was designed so that up to 256 service routines can be specified. Table A.2 in Appendix A contains the LC-3â€™s current complete list of operating system service routines.</li><li><strong>A table of the starting addresses</strong> of these 256 service routines. This table is stored in memory locations x0000 to x00FF. The table is referred to by various names by various companies. One company calls this table the System Control Block. Another company calls it the Trap Vector Table. Figure 9.10 shows the Trap Vector Table of the LC-3, with specific starting addresses highlighted. Among the starting addresses are the one for the character output service routine (memory location x0420), which is stored in memory location x0021, the one for the keyboard input service routine (location x04A0), stored in location x0023, and the one for the machine halt service routine (location x0520), stored in location x0025.</li><li><strong>The <code>TRAP</code> instruction</strong>. When a user program wishes to have the operating system execute a specific service routine on behalf of the user program, and then return control to the user program, the user program uses the TRAP instruction.</li><li><strong>A linkage</strong> back to the user program. The service routine must have a mechanism for returning control to the user program.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292177168-67358cc1-7bcc-4dc1-b6ca-fee7665db839.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_10,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292177168-67358cc1-7bcc-4dc1-b6ca-fee7665db839.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><strong>The TRAP Instruction</strong></p><ul><li>The TRAP instruction causes the service routine to execute by:</li></ul><ol><li>changing the <strong><code>PC</code></strong> to the starting address of the relevant service routine on the basis of its <strong>trap vector</strong>;</li><li>providing a way to get back to the program that executed the <strong><code>TRAP</code></strong> instruction. The â€œway backâ€ is referred to as a <strong>linkage</strong>;</li></ol><ul><li>As you know, the <strong><code>TRAP</code></strong> instruction is made up of two parts: the <strong><code>TRAP</code></strong> opcode 1111 and the <strong>trap vector</strong> (bits [7:0]), which identifies the service routine the user program wants the operating system to execute on its behalf. Bits [11:8] must be zero.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292696904-1ad69603-924c-41f3-a225-6a340486d062.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_24,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658292696904-1ad69603-924c-41f3-a225-6a340486d062.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>The EXECUTE phase of the TRAP instructionâ€™s instruction cycle does three things:</li></ul><ol><li>The <strong>PSR</strong> and <strong>PC</strong> are both pushed onto the system stack. Since the PC was incremented during the FETCH phase of the TRAP instructionâ€™s instruction cycle, the <strong>return linkage</strong> is automatically saved in the <strong>PC</strong>. When control returns to the user program, the <strong>PC</strong> will automatically be pointing to the instruction following the TRAP instruction. Note that the program requesting the trap service routine can be running either in <strong>Supervisor</strong> mode or in <strong>User</strong> mode. If in User mode, R6, the stack pointer, is pointing to the user stack. Before the <strong>PSR</strong> and <strong>PC</strong> can be pushed onto the system stack, the current contents of R6 must be stored in Saved <strong>USP</strong>, and the contents of Saved <strong>SSP</strong> loaded into R6.</li><li>PSR[15] is set to 0, since the service routine is going to require supervisor privilege to execute. PSR[10:8] are left unchanged since the priority of the TRAP routine is the same as the priority of the program that requested it.</li><li>The 8-bit trap vector is zero-extended to 16 bits to form an address that corresponds to a location in the <strong>Trap Vector Table</strong>. For the trap vector x23, that address is x0023. Memory location x0023 contains x04A0, the starting address of the TRAP x23 service routine. The PC is loaded with x04A0, completing the instruction cycle.</li></ol><ul><li>The <strong><code>RTI</code></strong> Instruction: To Return Control to the Calling Program</li><li>The <strong><code>RTI</code></strong> instruction (opcode &#x3D; 1000, with no operands) pops the top two values on the system stack into the <strong>PC</strong> and <strong>PSR</strong>. Since the <strong>PC</strong> contains the address following the address of the TRAP instruction, control returns to the user program at the correct address.</li><li>Finally, once the <strong>PSR</strong> has been popped off the system stack, **<code>PSR[15]</code>**must be examined to see whether the processor was running in <strong>User</strong> mode or <strong>Supervisor</strong> mode when the TRAP instruction was executed.</li></ul><p>Trap Routines for Handling I&#x2F;O</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369283680-182086d8-2a9d-49b2-870b-f7c42c1a68d2.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_13,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369283680-182086d8-2a9d-49b2-870b-f7c42c1a68d2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_13%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369308415-c0c6ccd0-c934-44ce-85ae-be317bdca8d1.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_14,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1658369308415-c0c6ccd0-c934-44ce-85ae-be317bdca8d1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>A Trap Routine for Halting the Computer</li></ul><h3 id="Interrupts-and-Interrupt-Driven-I-O"><a href="#Interrupts-and-Interrupt-Driven-I-O" class="headerlink" title="Interrupts and Interrupt-Driven I&#x2F;O"></a>Interrupts and Interrupt-Driven I&#x2F;O</h3><p>The essence of interrupt-driven I&#x2F;O is the notion that an I&#x2F;O device that may or may not have anything to do with the program that is running can(1) force the running program to stop,(2) have the processor execute a program that carries out the needs of the I&#x2F;O device, and then(3) have the stopped program resume execution as if nothing had happened.</p><p>Interrupt-driven I&#x2F;O do not waste time during input and output, instead, it can do useful work until it is notified that some I&#x2F;O device needs attention.</p><p><strong>Two parts to the process:</strong></p><ul><li>The mechanism that enables an I&#x2F;O device to interrupt the processor.</li><li>The mechanism that handles the interrupt request.</li></ul><p><strong>Part I:</strong></p><p><strong>Three things must be true to allow an I&#x2F;O device to interrupt the running program:</strong></p><ol><li>The I&#x2F;O device <strong>must want</strong> service: Check the ready bit in KBSR or DSR to confirm.</li><li>The device <strong>must have the right</strong> to request the service: that is the interrupt enable (IE) bit. In KBSR and DSR it is in bit[14]. The i<strong>nterrupt request signal from the I&#x2F;O device</strong> is the logical AND of the IE bit and the ready bit.</li></ol><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%203.png" alt="Untitled"></p><ol><li>The device request <strong>must be more urgent</strong> than what the processor is currently doing: it means the priority of the request must be higher than the priority of the program it wishes to interrupt.</li></ol><p><strong>The INT signal</strong></p><p>To stop the processor from continuing execution of its currently running program and service an interrupt request, the INT signal must be asserted.</p><p>The picture shows the status registers of several devices operating at various priority levels (PL). Any device that has bits [14] and [15] both set asserts its interrupt request signal. The interrupt request signals are input to a priority encoder, a combinational logic structure that selects the highest priority request from all those asserted. If the PL of that request is higher than the PL of the currently executing program, the INT signal is asserted.</p><p><img src="/Review%20Chap%209%204e7fd7f41df64af38e6bea1c5827e4ec/Untitled%204.png" alt="Untitled"></p><p>Finally, the test to enable the processor to stop and handle the interrupt. Recall from Chapter 4 that the instruction cycle continually sequences through the phases of the instruction cycle (FETCH, DECODE, EVALUATE ADDRESS, FETCH OPERAND, EXECUTE, and STORE RESULT). Each instruction changes the state of the computer, and that change is completed at the end of the instruction cycle for that instruction. That is, in the last clock cycle before the computer returns to the FETCH phase for the next instruction, the computer is put in the state caused by the complete execution of the current instruction.<br>Interrupts can happen at any time. They are asynchronous to the synchronous finite-state machine controlling the computer. For example, the interrupt signal could occur when the instruction cycle is in its FETCH OPERAND phase. If we stopped the currently executing program when the instruction cycle was in its FETCH OPERAND phase, we would have to keep track of what part of the current instruction has executed and what part of the current instruction still has work to do. It makes much more sense to ignore interrupt signals except when we are at an instruction boundary; that is, the current instruction has completed, and the next instruction has not yet started. Doing that means we do not have to worry about partially executed instructions, since the state of the computer is the state created by the completion of the current instruction, period!<br>The additional logic to test for the interrupt signal is to augment the last state of the instruction cycle for each instruction with a test. Instead of always going from the last state of one instruction cycle to the first state of the FETCH phase of the next instruction, the next state depends on the INT signal. If INT is not asserted, then it is business as usual, with the control unit returning to the FETCH phase to start processing the next instruction. If INT is asserted, then the next state is the first state of Part II, handling the interrupt request.</p><p><strong>Part II:</strong></p><p>Handling the interrupt goes through 3 stages:</p><ol><li>Initiate the interrupt.</li><li>Service the interrupt.</li><li>Return from the interrupt.</li></ol><p>First: Initiate</p><p>There are two things to do:</p><ol><li>Save the state of the interrupted program: The first step is to save enough of the state of the program that is running so that it can continue where it left off after the I&#x2F;O device request has been satisfied. That means storing current PC and PSR(These are the only state information LC-3 need to store during the execution).They are saved on the supervisor stack in the same way that PC and PSR are saved when a TRAP instruction is executed.</li><li>Load the state of the interrupt service routine:</li></ol><p>Once the state of the interrupted program has been safely saved on the supervisor stack, the second step is to load the PC and PSR of the interrupt service routine. Interrupt service routines are similar to the trap service routines we have already discussed. They are program fragments stored in system space. They service interrupt requests.</p><p>Most processors use the mechanism of vectored interrupts. You are familiar with this notion from your study of the trap vector contained in the TRAP instruction. In the case of interrupts, the eight-bit vector is provided by the device that is requesting the processor be interrupted. That is, the I&#x2F;O device transmits to the processor an eight-bit interrupt vector along with its interrupt request signal and its priority level. The interrupt vector corresponding to the highest priority interrupt request is the one supplied to the processor. It is designated INTV.</p><p>If the interrupt is taken, the processor expands the 8-bit interrupt vector (INTV) to form a 16-bit address, which is an entry into the Interrupt Vector Table. You know that the Trap Vector Table consists of memory locations x0000 to x00FF, each containing the starting address of a trap service routine. The Interrupt Vector Table consists of memory locations x0100 to x01FF, each containing the starting address of an interrupt service routine. The processor loads the PC with the contents of the location in the Interrupt Vector Table corresponding to the address formed by expanding the interrupt vector INTV.</p><p>The PSR is loaded as follows: Since no instructions in the service routine have yet executed, PSR[2:0] contains no meaningful information. We arbitrarily load it initially with 010. Since the interrupt service routine runs in privileged mode, PSR[15] is set to 0. PSR[10:8] is set to the priority level associated with the interrupt request.</p><p>This completes the initiation phase, and the interrupt service routine is ready to execute.</p><p>Second: Service(OMIT)</p><p>Finally: Return</p><p>The last instruction in every interrupt service routine is RTI, which stands for â€œreturn from trap or interruptâ€. When the processor finally accesses the RTI instruction, all the requirements of the I&#x2F;O device have been taken care of.</p>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 8</title>
      <link href="/2023/11/20/review-chap-8-4f43e889765545ecb6d7554902d57891/"/>
      <url>/2023/11/20/review-chap-8-4f43e889765545ecb6d7554902d57891/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-8"><a href="#Review-Chap-8" class="headerlink" title="Review Chap 8"></a>Review Chap 8</h1><h3 id="Subroutines"><a href="#Subroutines" class="headerlink" title="Subroutines"></a>Subroutines</h3><p>It is almost always the case that collections of fragments to invoke the program are available to user programmers to free them from writing their own. These collections are referred to as libraries.</p><p>In a library, a specified fragment can be invoked multiple times within the same program without having to specify its details. Such program fragments are called subroutines, or in C we call it functions.</p><ul><li>The Call&#x2F;Return Mechanism</li></ul><p>It allows us to execute this one three-instruction sequence multiple times by requiring us to include it as a subroutine in our program only once.</p><p>The programmer uses the call&#x2F;return mechanism to direct the computer each time via the call instruction to the code A, and after the computer has executed the code A, to the return instruction to the proper next instruction to be executed in the program.</p><p>Two instructions will be needed: JSR(R) calls the subroutinue; and RET(JMP R7) to go back to the main program.</p><ul><li><p>The JSR(R) instruction detailed</p><p>  The instruction uses one of two addressing modes for computing the starting address of the subroutine, PC-relative addressing or Base Register addressing. The LC-3 assembly language provides two different mnemonic names for the opcode, JSR and JSRR, depending on which addressing mode is used.</p><p>  The JSR (R) instruction does two things. Like all control instructions, it loads the PC, overwriting the incremented PC that was loaded during the FETCH phase of the JSR (R) instruction. In this case, the starting address of the subroutine is computed and loaded into the PC.</p><p>  The second thing the JSR (R) instruction does is save the return address in R7. The return address is the incremented PC, which is the address of the instruction following the JSR (R) instruction in the calling program.</p></li><li><p>Saving and Restoring Registers</p></li></ul><p>If a value in a register will be needed after something else is stored in that register, we must save it before something else happens and restore it before we can subsequently use it. We save a register value by storing it in memory; we restore it by loading it back into the register.</p><p>The save&#x2F;restore problem can be handled either by the calling program before the JSR occurs or by the subroutine.</p><p>In summary, we use the term â€œcaller-saveâ€ if the calling program handles the save&#x2F;restore problem, and we use the term â€œcallee-saveâ€ if the called program handles the problem. The appropriate one to handle the problem is the one that knows which registers will be destroyed by subsequent actions.</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>The stack is an abstract data type whose defining notion is that the last thing you stored in the stack is the first thing you remove from it. Simply, Last In, First Out, LIFO.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled.png" alt="Untitled"></p><p>In a stack implemented in hardware, as each value is added or removed, <strong>all the other values already on the stack move.</strong></p><ul><li>Implementation in Memory</li></ul><p>In the LC-3, R6 is the stack pointer.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%201.png" alt="Untitled"></p><p>These show the implementation in memory. Different from hardware,</p><p>Figure 8.9a shows an initially empty stack. Since there are no values on the stack, the stack pointer contains the address x4000, which is the address of the memory location just after the memory locations reserved for the stack. This setup makes sense because as we will see through the code for pushing and popping values, the stack grows towards zero.</p><p>Figure 8.9b illustrates the stack after pushing the value 18. Notice that the stack pointer now contains the address x3FFF, which becomes the new top of the stack.</p><p>In Figure 8.9c, we can see the stack after pushing the values 31, 5, and 12 in that order. It is important to note that the values inserted into the stack are stored in memory locations with decreasing addresses, as the stack grows towards zero.</p><p>Lastly, Figure 8.9d demonstrates the stack after popping the top two elements off the stack. The values 5 and 12, which were popped, are still present in memory locations x3FFD and x3FFC, respectively. However, these values cannot be accessed from memory as long as every access to memory is controlled by the stack mechanism.</p><p>Unlike the coin holder and computer hardware stack implementations discussed in the previous section, when values are pushed and popped to and from a stack implemented in sequential memory locations, the data already stored on the stack does not physically move.</p><ul><li>Underflow and Overflow</li></ul><ol><li>Underflow: Underflow happens when an attempt is made to pop a value from an empty stack. In other words, the stack is already empty, but a pop operation is requested. This results in an error condition because there are no values to retrieve from the stack. It is important to check for underflow conditions before performing a pop operation to avoid data loss or program malfunction.</li><li>Overflow: Overflow occurs when an attempt is made to push a value onto a stack that is already full. In LC-3, the stack is implemented within a defined region of memory with a fixed size. When the stack becomes full and additional values need to be pushed onto it, an overflow condition arises. This can lead to data corruption or unpredictable behavior in the program. It is crucial to monitor the stack usage and prevent overflow situations by appropriately managing the stack size or implementing error handling mechanisms.</li></ol><p>Both underflow and overflow conditions can be detected by monitoring the stack pointer and checking its position relative to the stack boundaries. Handling these scenarios effectively is essential to ensure the proper functioning and integrity of programs using the LC-3 stack.</p><p>Here are a complete picture, from which you can detect the way to avoid underflow and overflow.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%202.png" alt="Untitled"></p><h3 id="Recursion-a-Powerful-Technique-When-Used-Appopriately"><a href="#Recursion-a-Powerful-Technique-When-Used-Appopriately" class="headerlink" title="Recursion, a Powerful Technique When Used Appopriately"></a>Recursion, a Powerful Technique When Used Appopriately</h3><p>Recursion is a mechanism for expressing a function in terms of itself.</p><p>Good Exampleï¼ša maze</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%203.png" alt="Untitled"></p><h3 id="The-Queue"><a href="#The-Queue" class="headerlink" title="The Queue"></a>The Queue</h3><p>Unlike the stack, it is FIFO(first in first out). This means we need to keep track of two ends of the storage structure: a FRONT pointer for servicing and a REAR pointer for entering. Here are an example.</p><p><img src="/Review%20Chap%208%204f43e889765545ecb6d7554902d57891/Untitled%204.png" alt="Untitled"></p><p>The basic operations: Remove from front, Insert at rear.</p><p>Wrap-Around: It works by having our removal and insertion algorithms test the contents of FRONT and REAR for the value x8005. If we wish to insert, and REAR contains x8005, we know we have reached the end of our available storage and we must see if x8000 is available. If we wish to remove, we must see if FRONT contains the address x8005. If it does, the front of the queue is in x8000.</p><ul><li><strong>NOTE:</strong> We cannot let the empty queue and the full queue look the same, What should we do?</li></ul><p>Our answer is to allow the queue to store only n-1 elements if space for n elements has been allocated. That means, if inserting a nth element into the queue would cause FRONT to equal REAR, we do not allow that insertion. We declare the queue full when there are n-1 elements in the queue.</p><p>If the queue is empty, FRONT&#x3D;REAR.</p><p>Test of UNDERFLOW: just test if R3&#x3D;R4. If so, it means it is already empty.</p><p>Test of OVERFLOW: similarly, just add 1 to the REAR, if R3&#x3D;R4, it means it is already full.</p><h3 id="Character-Strings-Omit"><a href="#Character-Strings-Omit" class="headerlink" title="Character Strings(Omit)"></a>Character Strings(Omit)</h3>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 6&amp;7</title>
      <link href="/2023/11/14/review-chap-6-7-e66b76be92614538a66fb9a1d93b9783/"/>
      <url>/2023/11/14/review-chap-6-7-e66b76be92614538a66fb9a1d93b9783/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-6-7"><a href="#Review-Chap-6-7" class="headerlink" title="Review Chap 6&amp;7"></a>Review Chap 6&amp;7</h1><p>Away from machine codes, we are going to talk about programming languages. There are high-level and low-level languages. High-level languages tend to be ISA independent.</p><p>Assembly language is a low-level language. Low-level languages are ISA dependent. In fact, it is usually the case that each ISA has only one assembly language.</p><ul><li><em>Symbolic Addresses :</em> meaningful symbolic names to memory locations, such as SUM and PRODUCT, rather than use the memory locationsâ€™ 16-bit addresses. This makes it easier to differentiate which memory location is keeping track of a SUM and which memory location is keeping track of a PRODUCT.</li></ul><p>An Assembly Language Program</p><ul><li>The translation <strong>program</strong> is called an <strong>assembler</strong>, and the translation <strong>process</strong> is called <strong>assembly</strong>.</li><li>In LC-3 ISA, an instruction in assembly language consists of four parts:</li><li><code>Label Opcode Operands ; Comment</code></li><li><em><strong>Label</strong> &amp; <strong>Comment</strong> are optional, <strong>Opcode</strong> &amp; <strong>Operands</strong> are <strong>mandatory</strong></em>.</li></ul><p><strong>Opcode</strong> &amp; <strong>Operands</strong></p><ul><li>The <strong>Opcode</strong> is a symbolic name for the opcode of the corresponding LC-3 instruction.</li><li>The number of operands depends on the operation being performed.</li><li>A literal value must contain a symbol identifying the representation base of the number. We use <code>#</code> for decimal, <code>x</code> for hexadecimal, and <code>b</code> for binary.</li></ul><p><strong>Labels</strong></p><ul><li>Labels are symbolic names that are used to <strong>identify memory locations</strong> that are referred to explicitly in the program.</li><li>Label å®é™…ä¸Šæ˜¯ç»™ç‰¹å®šå†…å­˜çš„ä¸€ä¸ª aliasï¼Œå› æ­¤ä½ å¯ä»¥ç”¨å®ƒæ ‡è®° instructionsï¼Œä¹Ÿå¯ä»¥ç”¨å®ƒç´¢å¼• dataï¼</li><li>In LC-3 assembly language, a label consists of from 1 to 20 <strong>alphanumeric characters</strong> (i.e., each character is a capital or lower-case letter of the English alphabet, or a decimal digit), starting with a letter of the alphabet except <strong>reserved words</strong>.</li><li>There are two reasons for explicitly referring to a memory location:</li></ul><ol><li>The location is the <strong>target</strong> of a <strong>branch</strong> instruction.</li><li>The location contains a <strong>value</strong> that is <strong>loaded</strong> or <strong>stored</strong>.</li></ol><p><strong>Comments</strong></p><ul><li>The purpose of comments is to make the program more comprehensible to the human reader.</li><li>It is important to make comments that provide additional insight and do not just restate the obvious.</li><li>Another purpose of comments is to make the visual presentation of a program easier to understand.</li></ul><p><strong>Pseudo-Ops(Assembler Directives)</strong></p><ul><li>.ORIG: it tells the assembler where in memory to place the LC-3 program. e.g.: .ORIG x3000</li><li>.FILL: it tells the assembler to set aside the next location in the program and initialize it with the value of the operand. The value can be either a number or a label.</li><li>.BLKW: it tells the assembler to set aside some number of sequential memory locations(i.e., a BLocK of Words) in the program.</li><li>.STRINGZ: it tells the assembler to initialize a sequence of n+1 memory locations.</li></ul><p>It would result in the assembler initializing locations <code>x3010</code> through <code>x301D</code> to the following values:</p><p><img src="/Review%20Chap%206&7%20e66b76be92614538a66fb9a1d93b9783/Untitled.png" alt="Untitled"></p><ul><li>.END: it tells the assembler it has reached the end of the program and need not even look at anything after it. (In fact, .END does not exist at the time of execution, it is simply a delimiter)</li></ul><h3 id="The-Assembly-Process"><a href="#The-Assembly-Process" class="headerlink" title="The Assembly Process"></a>The Assembly Process</h3><p>Introduction</p><ul><li>If you have available an LC-3 assembler, you can cause it to translate your assembly language program into a machine language program by executing an appropriate command. In the LC-3 assembler that is generally available via the web, that command is assemble, and it requires as an argument the filename of your assembly language program.</li><li>eg: <code>assemble solution1.asm outfile</code></li></ul><p>A Two-Pass Process</p><ul><li>The objective of the first pass is to <strong>identify</strong> the actual binary <strong>addresses</strong> corresponding to the symbolic names (or <strong>labels</strong>). This set of correspondences is known as the <strong>symbol table</strong>.</li><li>In pass 1, we <strong>construct</strong> the <strong>symbol table</strong>. In pass 2, we <strong>translate</strong> the individual <strong>assembly language instructions</strong> into their corresponding <strong>machine language instructions</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 5</title>
      <link href="/2023/11/11/review-chap-5-ddcbb3165ab44277adc7d7cbc629f81c/"/>
      <url>/2023/11/11/review-chap-5-ddcbb3165ab44277adc7d7cbc629f81c/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-5"><a href="#Review-Chap-5" class="headerlink" title="Review Chap 5"></a>Review Chap 5</h1><ul><li><p>ISA(omit)</p><p>  The ISA specifies all the information about the computer that the software has to be aware of.</p><p>  The ISA specifies the memory organization, register set,and instruction set,including the opcodes, data types, and addressing modes of instructions in the instruction set.</p><p>  There are 65536 memory locations in LC-3, and 8 registers. We refer to 16 bits as one word, and we say the LC-3 is word-addressable.</p><p>  Each register in the set is called a general purpose register(GPR).</p><p>  Register file: what does every register contain.</p><ul><li><p>The instruction set: defined by its set of opcodes, data types and addressing modes.</p><p>  The addressing modes determine where the operands are located. The data type is the representation of operands in 0s and 1s.</p><h3 id="Opcodes"><a href="#Opcodes" class="headerlink" title="Opcodes"></a>Opcodes</h3><ul><li>Some ISAs have a very large number of opcodes, one for each of a very large number of tasks that a program may wish to carry out.</li><li>There are three different types of instructions, which means three different types of opcodes: operates, data movement, and control.</li><li>Operate instructions <strong>process</strong> information.</li><li>Data movement instructions <strong>move</strong> information between memory and the registers and between registers&#x2F;memory and input&#x2F;output devices.</li><li>Control instructions <strong>change</strong> the sequence of instructions that will be executed.</li></ul><p>  <strong>Data Types</strong></p><ul><li>Every opcode will <strong>interpret</strong> the bit patterns of its operands according <strong>to</strong> the data type it is designed to support.</li></ul><p>  <strong>Addressing Modes</strong></p><ul><li>An <strong>addressing mode</strong> is a mechanism for specifying where the operand is located.</li><li>LC-3 supports five addressing modes:</li><li><strong>immediate</strong>&#x2F;<strong>literal</strong> (the same)</li><li><strong>register</strong></li><li>3 <strong>memory</strong> addressing modes:</li><li><strong>PC-relative</strong></li><li><strong>indirect</strong></li><li><strong>Base+offset</strong></li></ul></li></ul></li></ul><p><img src="/Review%20Chap%205%20ddcbb3165ab44277adc7d7cbc629f81c/Untitled.png" alt="Untitled"></p><ul><li><strong>Condition Codesï¼ˆCCï¼‰</strong></li><li>The LC-3 has three single-bit registers that are individually set (set to 1) or cleared (set to 0) <strong>each time</strong> one of the eight general purpose registers is written into <strong>as a result</strong> of execution of one of the operate instructions or one of the load instructions.</li><li>Each <strong>operate instruction</strong> performs a computation and writes the result into a general purpose register.</li><li>Each <strong>load instruction</strong> reads the contents of a memory location and writes the value found there into a general purpose register.</li><li>The three single-bit registers are called <strong>N</strong>, <strong>Z</strong>, and <strong>P</strong>, corresponding to their meaning: <strong>n</strong>egative, <strong>z</strong>ero, and <strong>p</strong>ositive. And their value will be modified each time a GPR is written by an operate or a load instruction.</li><li>They are referred to as condition codes because the condition of those bits are used to change the sequence of execution of the instructions in a computer program. (e.g. <code>BR</code>â€˜s condition.)</li></ul><p>ç»“æœæˆ‘ç ”ç©¶æ¯ä¸ªæŒ‡ä»¤çš„æ•°æ®é€šè·¯åˆç»™æˆ‘ç»•æ™•äº†ã€‚ã€‚ã€‚æˆ‘æ˜¯çœŸèœ</p><ul><li><strong>Operate Instructions</strong></li><li><strong><code>ADD</code></strong>, <strong><code>AND</code></strong>, and <strong><code>NOT</code></strong></li><li>The <strong><code>NOT</code></strong> (opcode &#x3D; 1001) instruction is the only (in LC-3) operate instruction that performs a <strong>unary</strong> operation. See docs for details.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856236536-0606ce17-259e-4116-88ab-9d382a258c6b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_17,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856236536-0606ce17-259e-4116-88ab-9d382a258c6b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_17%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Inmmediates</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856377554-22f4fbf6-f586-4caa-acfe-214c1203dfaf.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856377554-22f4fbf6-f586-4caa-acfe-214c1203dfaf.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Since the immediate operand havs a size less than a word, so not all 2â€™s complement integers can be immediate operands.</li><li>The <strong>LEA</strong> Instruction (Although Not Really an Operate)</li><li>It does not really operate on data, it simply <strong>loads</strong> a register with an <strong>address</strong>. It clearly does not move data from memory to a register, nor is it a control instruction. We had to put it somewhere, so we chose to discuss it here! See docs for details.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856727821-214fb9a4-b5f3-4318-ab7d-a7b0fb9d0d59.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657856727821-214fb9a4-b5f3-4318-ab7d-a7b0fb9d0d59.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>We shall see shortly that the LEA instruction is useful to <strong>initialize</strong> a register with an address that is very close to the address of the instruction doing the initializing.</li><li><strong>Data Movement Instructions</strong></li><li><em>We will ignore for now the business of moving information from input devices to registers and from registers to output devices which will be an important part of Chapter 9.</em>  <em>In this chapter, we will confine ourselves to moving information between memory and the general purpose registers.</em></li><li>The process of moving information from memory to a register is called a <strong>load</strong>.</li><li>The process of moving information from a register to memory is called a <strong>store</strong>.</li><li>In both cases, the information in the location containing the <strong>source</strong> operand remains <strong>unchanged</strong>.</li><li>In both cases, the location of the <strong>destination</strong> operand is <strong>overwritten</strong>.</li><li>The LC-3 contains six instructions that move information: <strong><code>LD</code></strong>, <strong><code>LDR</code></strong>, <strong><code>LDI</code></strong>; <strong><code>ST</code></strong>, <strong><code>STR</code></strong>, <strong><code>STI</code>.</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857321834-ff385e31-c387-4306-9960-d3234706d177.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_20,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857321834-ff385e31-c387-4306-9960-d3234706d177.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Data movement instructions require two operands, a <strong>source</strong> and a <strong>destination</strong>.</li><li><strong>PC-Relative Mode</strong></li><li><strong><code>LD</code></strong> and <strong><code>ST</code></strong> specify the PC-relative addressing mode.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857885236-4a6ff41d-4d30-4211-b725-728f7927fa3d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_22,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657857885236-4a6ff41d-4d30-4211-b725-728f7927fa3d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_22%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Indirect Mode</strong></li><li><strong><code>LDI</code></strong> and <strong><code>STI</code></strong> specify the <strong>indirect</strong> addressing mode that means the <strong>address</strong> of the address of the operand to be loaded or stored.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858056522-1fa1bc60-4bf1-48b5-87ef-5b98b3335631.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_20,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858056522-1fa1bc60-4bf1-48b5-87ef-5b98b3335631.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_20%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>åœ¨å¯»å€è¿‡ç¨‹ä¸­è¿›è¡Œä¸€æ¬¡è¿­ä»£ï¼Œç”¨ C çš„<code>[]</code>ç¬¦å·å†™çš„è¯æ„Ÿè§‰å°±åƒæ˜¯<code>mem[ mem[idx] ]</code>ã€‚</li><li><strong>Base+offset Mode</strong></li><li><code>LDR</code> and <code>STR</code> specify the <strong>Base+offset</strong> addressing mode. The Base+offset mode is so named because the address of the operand is obtained by <strong>adding</strong> a sign-extended six-bit <strong>offset</strong> to a <strong>base register</strong>.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858232090-0d249491-0b39-4e60-8f72-96893439de0b.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657858232090-0d249491-0b39-4e60-8f72-96893439de0b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li>Note that the Base+offset addressing mode also allows the address of the operand to be <strong>anywhere</strong> in the computerâ€™s memory.</li><li>æ‰€ä»¥å› ä¸ºè¿™ä¸ªç‰¹æ€§ï¼Œè¿™ç§å¯»å€æ¨¡å¼æ˜¯åœ¨é•¿è·ç¦»è·³è½¬ä¸­è¾ƒä¸ºå®ç”¨çš„ã€‚</li></ul><h3 id="Control-Instructions"><a href="#Control-Instructions" class="headerlink" title="Control Instructions"></a>Control Instructions</h3><p>The LC-3 has five opcodes that enable the sequential execution flow to be broken:</p><ul><li>conditional branch</li><li>unconditional jump</li><li>subroutine call (sometimes called function)</li><li><strong><code>TRAP</code></strong> (service call)</li><li><strong><code>RTI</code></strong> (Return from Trap or Interrupt)</li></ul><p>Two Methods of <strong>Loop</strong> Control</p><ul><li><strong>loop body</strong> &amp; <strong>iteration</strong> fo the loop body</li><li>Loop Control with a <strong>Counter</strong></li><li>Loop Control with a <strong>Sentinel</strong></li><li>We append to our sequence of values to be processed a value that we know ahead of time can <strong>never occur</strong> (i.e., the <strong>sentinel</strong>).</li><li>å°±æ˜¯éœ€è¦ä¸€ä¸ªå“¨å…µæ ‡è®°åºåˆ—çš„å°¾éƒ¨ï¼Œå½“è®¿é—®åˆ°è¯¥å“¨å…µçš„æ—¶å€™è·³å‡ºå¾ªç¯ã€‚</li><li>eg: if we are adding a sequence of numbers, a sentinel could be a letter <code>A</code> or a &#96;&#96;, that is, something that is not a number.</li><li>BR instruction</li></ul><p><img src="/Review%20Chap%205%20ddcbb3165ab44277adc7d7cbc629f81c/Untitled%201.png" alt="Untitled"></p><ul><li>JMP Instruction TRAP instruction(æˆ‘ä»¬ä¼šåœ¨åé¢çš„ç« èŠ‚ä¸­è®¨è®ºä»–ä»¬ï¼Œç°åœ¨è¿˜ä¸æ˜¯æ—¶å€™ï¼‰</li><li>Another Example: Counting Occurrences of a Character</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859510501-fb0532f9-02e7-4319-bf78-37597547c1dc.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_11,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859510501-fb0532f9-02e7-4319-bf78-37597547c1dc.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_11%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859523144-18c15d17-9367-4960-a418-6f7e62391d6e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_18,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859523144-18c15d17-9367-4960-a418-6f7e62391d6e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_18%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>The Data Path Revisited</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859746575-60df7310-d152-4bec-80b2-b965ade04159.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_23,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657859746575-60df7310-d152-4bec-80b2-b965ade04159.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Basic Components</strong> of the Data Path</li><li>The <strong>Global Bus</strong></li><li>The LC-3 global bus consists of <strong>16</strong> wires and associated electronics. It allows one structure to transfer up to 16 bits of information to another structure by making the necessary electronic connections on the bus.</li><li>Note that each structure that supplies values to the bus has a triangle just behind its input arrow to the bus. This triangle (called a <strong>tri-state device</strong>) allows the computerâ€™s control logic to enable exactly one supplier to provide information to the bus at any one time.</li><li>The pros and cons of a <strong>single global bus</strong> is yet another topic that will have to wait for later in your education.</li><li><strong>Memory</strong></li><li>One of the most important parts of any computer is the memory that <strong>contains both instructions and data</strong>.</li><li>Memory is accessed by loading the memory address register (<strong>MAR</strong>) with the address of the location to be accessed. To perform a load, control signals then read the contents of that memory location, and the result of that read is delivered by the memory to the memory data register (<strong>MDR</strong>). On the other hand, to perform a store, what is to be stored is loaded into the <strong>MDR</strong>. Then the control signals assert a write enable (<strong>WE</strong>) signal in order to store the value contained in <strong>MDR</strong> in the memory location specified by MAR.</li><li>The <strong>ALU</strong> and the <strong>Register File</strong></li><li>The results of an ALU operation are (a) a <strong>result</strong> that is stored in one of the registers, and (b) the three single-bit <strong>condition codes</strong>.</li><li>The <strong>PC</strong> and the <strong>PCMUX</strong></li><li>The <strong>MARMUX</strong></li><li>The <strong>Instruction Cycle Specific to the LC-3</strong></li><li><strong>FETCH</strong></li><li><strong>DECODE</strong></li><li><strong>EVALUATE ADDRESS</strong></li><li><strong>OPERAND FETCH</strong></li><li><strong>EXECUTE</strong></li><li><strong>STORE RESULT</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 4</title>
      <link href="/2023/11/09/review-chap-4-db0804e57cb947bda974a470320dbd90/"/>
      <url>/2023/11/09/review-chap-4-db0804e57cb947bda974a470320dbd90/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-4"><a href="#Review-Chap-4" class="headerlink" title="Review Chap 4"></a>Review Chap 4</h1><p>To get a task done by a computer, we need two things: (a) a <strong>computer program</strong> that specifies what the computer must do to perform the task, and (b) the <strong>computer</strong> that is to carry out the task.</p><ul><li>The <strong>instruction</strong> is the smallest piece of work specified in a computer program.</li><li>John von Neumann proposed a fundamental model of a computer for processing computer programs in 1946. Here is itâ€™s basic components:</li></ul><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/1692688049747.png" alt="1692688049747.png"></p><ul><li>Memory</li></ul><p>For nowadays computer: 2^34 by 8 bits.</p><p>Addressability: 8 bits.</p><p>Address space: 2^34.</p><p>Each location has 34-bit address, for n bits can represent unique ly 2^n items.</p><ul><li>MAR and MDR</li></ul><p>To write (or store) a value in a memory location, we first write <strong>the address of the memory location</strong> in the <strong>MAR</strong> (memoryâ€™s address register), the value (interrogated from the computerâ€™s memory) to be stored in the <strong>MDR</strong> (memoryâ€™s data register).è¿™å¹¶ä¸æ„å‘³ç€ MDR é‡Œå­˜çš„ä¸å¯èƒ½æ˜¯ä¸ªåœ°å€ï¼</p><p>The <strong>address of that location</strong> will be written to the (<strong>MAR</strong>) and then we <strong>interrogate the computerâ€™s memory</strong>.</p><p>The <strong>information stored</strong> in the location having that address will be placed in the <strong>m</strong>emoryâ€™s <strong>d</strong>ata <strong>r</strong>egister (<strong>MDR</strong>).</p><ul><li>Processing Unit</li></ul><p>The actual processing of information in the computer is carried out by the processing unit. The processing unit in a modern computer can consist of many sophisticated complex functional units, each performing one particular operation.</p><p><strong>ALU:</strong> the simplest processing unit, is the abbreviation for Arithmetic and Logic Unit, which is capable of performing basic arithmetic functions and basic logic operations.</p><p>In LC-3, ALU can perform ADD, AND, and NOT operations.</p><ul><li>Each ISA has its own word length, depending on the intended use of the computer.</li><li>Most microprocessors today that are used in PCs or workstations have a word length of 64 bits (as is the case with Intelâ€™s â€œCoreâ€ processors) or 32 bits (as is the case with Intelâ€™s â€œAtomâ€ processors). Even most microprocessors now used in cell phones have 64-bit word lengths, such as Appleâ€™s A7 through A11 processors, and Qualcommâ€™s SnapDragon processors. However, the microprocessors used in very inexpensive applications often have word lengths of as little as 16 or even 8 bits.</li><li>LC-3 has a word length of 16 bits.</li><li>It is almost always the case that a computer provides some <strong>small amount of storage</strong> very close to the ALU to allow results to be <strong>temporarily stored</strong> if they will be needed to produce additional results <strong>in the near future</strong>. (They are important.)</li><li>The most common form of temporary storage is a set of <strong>registers</strong>.</li><li>Typically, the size of each register is identical to the size of values processed by the ALU; that is, they <strong>each contain one word</strong>.</li><li>Current microprocessors typically contain 32 registers, each consisting of 32 or 64 bits, depending on the architecture.</li><li>The LC-3 has eight registers (R0, R1, â€¦ R7), each containing 16 bits.</li></ul><p>ä¹Ÿå°±æ˜¯ä¸€èˆ¬ä¼šæ¶‰åŠä¸€äº›å¯„å­˜å™¨æ¥å­˜å‚¨è®¡ç®—çš„ä¸­é—´ç»“æœã€‚</p><ul><li>Input and Output(å¥½åƒä¸é‡è¦ï¼‰</li><li>Control Unitï¼ˆit is like the conductor of an orchestra)</li></ul><p>The control unit has an instruction register to contain that instruction to keep track of which instruction is being executed. And to keep track of which instruction is to be happened next, the control unit has a register contains next instructionâ€™s address, which is called program counter(PC).</p><h1 id="The-LC-3-An-Example-von-Neumann-Machine"><a href="#The-LC-3-An-Example-von-Neumann-Machine" class="headerlink" title="The LC-3: An Example von Neumann Machine"></a>The LC-3: An Example von Neumann Machine</h1><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/Untitled.png" alt="Untitled"></p><ul><li><p>Two kinds of arrowheads:</p></li><li><p>Filled-in: denote data elements that flow along the corresponding paths.</p><p>  <img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687710479-37d632d3-4794-4a2b-8330-c944922c689e.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_9,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687710479-37d632d3-4794-4a2b-8330-c944922c689e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p></li><li><p>Not-filled in: denote control signals that control the processing of the data elements.</p><p>  <img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687737528-a4ac7ebd-3c0b-4ec3-8f7a-22bd2aeb64c9.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_9,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657687737528-a4ac7ebd-3c0b-4ec3-8f7a-22bd2aeb64c9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_9%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><p>  <strong>MEMORY</strong> consists of the storage elements, along with the <strong>MAR</strong> for addressing individual locations and the <strong>MDR</strong> for holding the contents of a memory location on its way to&#x2F;from the sotrage.</p><ul><li>NOTE: the <strong>MAR</strong> and <strong>MDR</strong> each contains 16 bits, reflecting the fact that the memory address space of the LC-3 is 2^16 <strong>memory locations</strong> and the LC-3 is <strong>16-bit addressable</strong>.</li></ul><p>  <strong>INPUT&#x2F;OUTPUT</strong> consists of a keyboard and a monitor.</p><ul><li>The simplest keyboard requires two registers: a <strong>KBDR</strong> (<strong>k</strong>ey<strong>b</strong>oard <strong>d</strong>ata <strong>r</strong>egister) for holding the ASCII codes of keys struck and a <strong>KBSR</strong> (<strong>k</strong>ey<strong>b</strong>oard <strong>s</strong>tatus <strong>r</strong>egister) for maintaining status information about the keys struck.</li><li>The simplest monitor requires two registers: a <strong>DDR</strong> (<strong>d</strong>isplay <strong>d</strong>ata <strong>r</strong>egister) for holding the ASCII code of something to be displayed on the screen and a <strong>DSR</strong> (<strong>d</strong>isplay <strong>s</strong>tatus <strong>r</strong>egister) for maintaining associated status information.</li></ul><p>  <strong>THE PROCESSING UNIT</strong> consists of a <strong>functional unit</strong> (<strong>ALU</strong> here) that performs arithmetic and logic operations and <strong>eight registers</strong> (R0, â€¦ R7) for storing temporary values that will be needed in the near future as operands for subsequent instructions.</p><ul><li>The LC-3 ALU can perform one <strong>arithmetic</strong> operation (<strong>addition</strong>) and two <strong>logical</strong> operations (<strong>bitwise AND</strong> and <strong>bitwise NOT</strong>).</li></ul><p>  <strong>THE CONTROL UNIT</strong> consists of all the structures needed to <strong>manage</strong> the processing that is carried out by the computer.</p><ul><li>Its most important structure is the <strong>finite state machine</strong>, which directs all the activity.</li><li>Note the <strong>CLK</strong> input to the finite state machine. It specifies how long each clock cycle lasts.</li><li>The <strong>IR</strong> (<strong>i</strong>nstruction <strong>r</strong>egister) is also an input to the finite state machine since the LC-3 instruction being processed determines what activities <strong>must</strong> be carried out.</li><li>The <strong>PC</strong> (<strong>p</strong>rogram <strong>c</strong>ounter) is also a part of the control unit; it keeps track of the next instruction to be executed after the current instruction finishes.</li><li>Note that all the external <strong>outputs</strong> of the <strong>finite state machine</strong> in the figure have arrowheads that are <strong>not filled in</strong>. These outputs <strong>control</strong> the <strong>processing</strong> throughout the computer.</li><li>eg: <strong>ALUK</strong>: controls the <strong>operation</strong> performed in the <strong>ALU</strong> (<strong>ADD</strong>&#x2F;<strong>AND</strong>&#x2F;<strong>NOT</strong>) during the current clock cycle.</li><li>eg: <strong>GateALU</strong>: determines whether or not the output of the ALU is provided to the <strong>processor bus</strong> during the current clock cycle.</li><li>å³æœ‰é™å…ƒçŠ¶æ€æœºçš„æ‰€æœ‰è¾“å‡ºéƒ½éè®¡ç®—æ•°æ®ï¼Œè€Œæ˜¯ç”¨æ¥æ§åˆ¶å„ä¸ªå…ƒä»¶ï¼Œæ§åˆ¶æŒ‡ä»¤è¡Œä¸ºçš„ã€‚</li></ul><h1 id="Instruction-Processing"><a href="#Instruction-Processing" class="headerlink" title="Instruction Processing"></a>Instruction Processing</h1><p>  The central idea in the von Neumann model of computer processing is that the program and data are both stored as sequences of bits in the computerâ€™s memory, and the program is executed one instruction at a time under the ditrection of the control unit.</p><ul><li>The instruction is made up of two parts, the opcode(what the instruction does) and the operands(who it does it to).</li><li>Three kinds of instructions: <em>operates</em>, <em>data movement</em>, and <em>control</em>.</li><li><strong>Operate</strong> instructions operate on data.</li><li>LC-3 has three operate instructions: <strong>ADD</strong>&#x2F;<strong>AND</strong>&#x2F;<strong>NOT</strong></li><li><strong>Data movement</strong> instructions move information from the processing unit to and from memory ****and to&#x2F;from input&#x2F;output devices.</li><li>The LC-3 has six data movement instructionï¼š <em><em>LD</em>&#x2F;ST</em>**.</li><li><strong>Control</strong> instructions are necessary for altering the sequential processing of instructions. ï¼ˆæ¯”å¦‚æŒ‡ä»¤é—´çš„è·³è½¬å•¥çš„ï¼‰</li><li>An LC-3 instruction consists of 16 bits (one word), numbered from left to right, bit [15] to bit [0].</li><li><strong>Bits [15:12]</strong> contain the <strong>opcode</strong>. This means there are at most 16 distinct opcodes. Actually, we use only 15 of the possible four-bit codes. One is reserved for some future use.</li><li><strong>Bits [11:0]</strong> are used to figure out <strong>where the operands are</strong>.</li></ul><p>  è‡³äº15ä¸ªæŒ‡ä»¤éƒ½æ˜¯ä»€ä¹ˆã€‚ã€‚ã€‚æˆ‘ç´¯äº†ï¼Œç¿»appendix Açœ‹å§.</p></li></ul><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/Untitled%201.png" alt="Untitled"></p><ul><li>The Instruction Cycle(Not the Clock Cycle!)</li></ul><p>The entire sequence of steps needed to process an instruction is called the <em>instruction cycle.</em></p><p>Here are the six sequential phases of the instruction cycle:</p><p><strong>FETCH</strong></p><ul><li>The FETCH phase obtains the next instruction from memory and loads it into the <strong>IR</strong> (instruction register) of the control unit.</li><li>The <strong>PC</strong> contains the address of the next instruction to be processed.</li><li>So the FETCH do the following things:</li><li>Load the MAR with the contents of the PC, and simultaneously <strong>increment</strong> the <strong>PC</strong>. <em>[one clock cycle]</em></li><li>Interrogate memory, resulting in the instruction being placed in the MDR. <em>[one clock cycle or more]</em></li><li>Load the IR with the contents of the MDR. <em>[one clock cycle]</em></li><li>Each of these steps is under the direction of the <strong>control unit</strong>.</li><li>è·å–æŒ‡ä»¤æ•°æ®ï¼Œå¹¶æ›´æ–°æ§åˆ¶æ¨¡å—ã€‚</li></ul><p><strong>DECODE</strong></p><ul><li>The DECODE phase examines the instruction in order to figure out what the microarchitecture is being asked to do.</li><li>ä¾æ® opcode è¿›è¡Œè·¯ç”±ï¼Œæ‰¾åˆ°æ¥ä¸‹æ¥è¦åšä»€ä¹ˆã€‚</li></ul><p><strong>EVALUATE ADDRESS</strong></p><ul><li>This phase computes the address of the memory location that is needed to process the instruction.</li><li>For instructions that neednâ€™t deal with an address (such as ADD with bits [5] &#x3D; 0), the EVALUATE ADDRESS phase is not needed.</li><li>å¯¹äºéƒ¨åˆ†æŒ‡ä»¤ï¼Œå®ƒä»¬æ¶‰åŠä¸€ä¸ªéœ€è¦è®¡ç®—æ‰èƒ½å¾—åˆ°çš„åœ°å€ï¼Œè€Œè¿™ä¸ªè®¡ç®—è¿‡ç¨‹å°±æ˜¯åœ¨è¿™ä¸€éƒ¨æ‰§è¡Œã€‚</li></ul><p><strong>FETCH OPERANDS</strong></p><ul><li>This phase obtains the source operands needed to process the instruction.</li></ul><p><strong>EXECUTE</strong></p><ul><li>This phase carries out the execution of the instruction.</li></ul><p><strong>STORE RESULT</strong></p><ul><li>The final phase of an instructionâ€™s execution. The result is written to its designated destination.</li><li>Not all instructions require all six phases.</li></ul><p><strong>Control of the Instruction Cycle</strong></p><ul><li>The instruction cycle is controlled by a synchronous finite state machine.</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657770087716-bcd10ab5-5c28-45ea-af94-981a5407dbac.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_23,text_SXNzaGlraeS_ri3or63pm4A=,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10" alt="https://cdn.nlark.com/yuque/0/2022/png/22387144/1657770087716-bcd10ab5-5c28-45ea-af94-981a5407dbac.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_SXNzaGlraeS_ri3or63pm4A%3D%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10"></p><ul><li><strong>Halting</strong> the Computer (the <strong>TRAP</strong> Instruction)</li></ul><p><img src="/Review%20Chap%204%20db0804e57cb947bda974a470320dbd90/Untitled%202.png" alt="Untitled"></p><ul><li>If we need to stop this potentially infinite sequence of instruction cycles, we should stop the <strong>clock</strong>.</li><li>å°±æ˜¯é€šè¿‡è‡ªé™·æ¥å§”æ‰˜è®¡ç®—æœºè¿›è¡Œä¸€äº›ç”¨æˆ·æƒé™æ— æ³•å®Œæˆçš„äº‹æƒ…ã€‚ç±»ä¼¼äºå°†æŸäº›æ¶‰åŠåˆ°åº•å±‚çš„è¡Œä¸ºå°è£…èµ·æ¥ï¼Œæ¥å¢åŠ å®‰å…¨æ€§ã€‚</li><li>In the LC-3, as in many other machines, it is done under control of the operating system. For now it is enough to know that if a user program requires help from the operating system, it requests that help with the <strong>TRAP</strong> instruction (opcode &#x3D; 1111) and an eight-bit code called a <strong>trap vector</strong>, which identifies the help that the user program needs. The eight-bit code <strong>x25</strong> tells the operating system that the program has finished executing and the computer can stop processing instructions.</li></ul>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 3</title>
      <link href="/2023/11/05/review-chap-3-d0d116bbfd7a4a57bb62227c9d2c6bc8/"/>
      <url>/2023/11/05/review-chap-3-d0d116bbfd7a4a57bb62227c9d2c6bc8/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-3"><a href="#Review-Chap-3" class="headerlink" title="Review Chap 3"></a>Review Chap 3</h1><ul><li><p>Transistor: MOS transistors, which are below our lowest level of abstraction. Transistor has three terminals: the <strong>gate</strong>, the <strong>source</strong> and the <strong>drain</strong>.</p></li><li><p>Two types of MOS: P-type, when the gate is supplied with 0 volts, it acts as a piece of wire(short circuit), when supplied with 1.2 volts, it acts like an open circuit; N-type, which is opposite to P-type. when there are no volts, it acts like an open circuit, when there are 1.2 volts in the gate, it acts like a piece of wire(short circuit).</p><p>  <img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled.png" alt="Untitled"></p>  <aside>  ğŸ’¡ N-type    </aside>  <p>  <img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%201.png" alt="Untitled"></p>  <aside>  ğŸ’¡ P-type    </aside>  <p>  åœ¨ä½¿ç”¨ä¸Šï¼ŒN ç®¡å’Œ P ç®¡çš„ä½¿ç”¨æ–¹å‘æ˜¯åè¿‡æ¥çš„ï¼Œå¹¶ä¸”åœ¨å……å½“å¼€å…³æ—¶ï¼Œä¸€èˆ¬ä»¥ N ç®¡ä½œä¸‹ç®¡ï¼ŒP ç®¡åšä¸Šç®¡ï¼Œä¸»è¦åŸç†å‚è€ƒ<a href="https://zhuanlan.zhihu.com/p/96545244">è¿™ç¯‡æ–‡ç« </a>ã€‚å¯ä»¥å‘ç°ï¼Œåœ¨ç®€åŒ–å›¾ä¸­çœ‹ä¸å‡ºå“ªå¤´æ˜¯æºæå“ªå¤´æ˜¯æ¼æï¼Œåªåœ¨ Gate å¤„åŠ äº†ä¸€ä¸ªéæ¥è¡¨ç¤ºï¼Œä½†æ˜¯å®é™…ä¸Šä¸¤ä¸ªçš„ä½¿ç”¨æ–¹å‘å¤§æ¦‚æ˜¯ç›¸åçš„ï¼ˆä¾‹å¦‚ä¸‹å›¾ï¼‰</p></li></ul><h1 id="Logic-Gates"><a href="#Logic-Gates" class="headerlink" title="Logic Gates"></a>Logic Gates</h1><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%202.png" alt="Untitled"></p><aside>ğŸ’¡ The NOT Gates (Inverter)</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%203.png" alt="Untitled"></p><aside>ğŸ’¡ The NOR Gates</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%204.png" alt="Untitled"></p><aside>ğŸ’¡ The OR Gates</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%205.png" alt="Untitled"></p><aside>ğŸ’¡ AND Gates (AB-D)Â  Â  Â  Â andÂ  Â  Â  Â  NAND Gates (AB-C)</aside><p>â€¢ å¯ä»¥å‘ç°ï¼Œä¸æˆ–é—¨çš„è®¾è®¡éƒ½æ˜¯ä»ä¸éå’Œæˆ–éå¼€å§‹çš„ï¼Œè€Œå…¶ç»“æ„çš„ä¸ŠåŠéƒ¨åˆ†æ˜¯ä¸€ä¸ªâ€œæˆ–â€é€‰æ‹©é«˜ç”µåŠ¿çš„å…³ç³»ï¼Œä¸‹åŠéƒ¨åˆ†æ˜¯â€œä¸â€é€‰æ‹©æ¥åœ°çš„å…³ç³»ï¼Œæ·±å…¥æ„Ÿå—ä¸€ä¸‹è¿™ä¸€å±‚ï¼Œå°±ä¼šå‘ç°è¿™äº›ç”µè·¯éƒ½å¾ˆå¥½è®¾è®¡ã€‚</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%206.png" alt="Untitled"></p><aside>ğŸ’¡ raise our level of abstraction and use the symbols here</aside><p>Also, you can consider using gates with more than two inputs, whose truth table can be easy to draw.</p><h1 id="Combinational-Logic-Circuits"><a href="#Combinational-Logic-Circuits" class="headerlink" title="Combinational Logic Circuits"></a>Combinational Logic Circuits</h1><p>1.Decoder</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%207.png" alt="Untitled"></p><ul><li>Exactly one of its outputs is 1 and all the rest are 0s.</li><li>In general, decoders have n  inputs and  2^n outputs.</li><li>We say the output line that detects the input pattern is <a href="https://zh.wikipedia.org/wiki/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">ğŸ”—</a><strong>asserted</strong>.</li><li>The decoder is useful in determining how to interpret a bit pattern.</li></ul><ol><li>Mux(multiplexer): to select one of the inputs and connect it to the output.</li></ol><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%208.png" alt="Untitled"></p><aside>ğŸ’¡ a 2-to-1 mux, (c) shows the standard representation for a mux</aside><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%209.png" alt="Untitled"></p><aside>ğŸ’¡ a four-input mux, (c) shows the standard representation for a four-input mux</aside><ul><li>The select signal (S in Figure 3.12) determines which input is connected to the output.</li><li>We say S selects the source of the mux (either A or B) to be routed through to the output C.</li><li>In general, a mux consists of 2^n inputs and n select lines.</li><li>ç”¨æ¥å®ç°è¾“å…¥çš„<strong>è·¯ç”±</strong>ï¼Œæœ‰ç‚¹åƒé“è½¨çš„å˜é“è£…ç½®ï¼Œé€šè¿‡ S çš„æ•°æ®æ¥é€‰æ‹©ä½¿ç”¨å“ªä¸€æ¡è¾“å…¥ã€‚</li></ul><ol><li>One-Bit Adder (Full Adder)</li></ol><p>The truth table of it is below.</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2010.png" alt="Untitled"></p><ul><li>It describes the result of binary addition on <strong>one column</strong> of bits within two <em>n</em>bit operands.</li><li>Aj and Bj are digits from inputs,Cj is the carry number from  Aj-1 + Bj-1 , and Sj is the (j+1)th digit of output.</li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2011.png" alt="Untitled"></p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2012.png" alt="Untitled"></p><p>å¦‚æœä¸è€ƒè™‘è¿›ä½çš„è¯ï¼Œè¿™æ˜¯ä¸€ä¸ªåŠåŠ å™¨ï¼›ï¼ˆå¦‚å›¾ä¸­æœ€å³è¾¹ï¼‰è€ƒè™‘è¿›ä½çš„è¯ï¼Œè¿™æ˜¯ä¸€ä¸ªå…¨åŠ å™¨ï¼ˆå¦‚å…¶ä»–éƒ¨åˆ†ï¼‰ã€‚</p><ol><li>The Programmable Logic Array(PLA) in Chinese:å¯ç¼–ç¨‹é˜µåˆ—</li></ol><ul><li>The implementation algorithm is simply to connect the output of an AND gate to the input of an OR gate if the corresponding row of the truth table produces an output 1 for that output column. Hence the notion of <strong>programmable</strong>. That is, we say we program the connections from AND gate outputs to OR gate inputs to implement our desired logic functions.</li><li><strong>Logical Completeness</strong></li></ul><p> We say that the set of gates {AND, OR, NOT} is <strong>logically complete</strong> because we can build a circuit to carry out the specification of any truth table we wish without using any other kind of gate.</p><h1 id="Basic-Storage-Elements"><a href="#Basic-Storage-Elements" class="headerlink" title="Basic Storage Elements"></a>Basic Storage Elements</h1><h2 id="R-S-Latch"><a href="#R-S-Latch" class="headerlink" title="R-S Latch"></a>R-S Latch</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2013.png" alt="Untitled"></p><p>R-S latch can store a bit of information. And the circuit is above.</p><ul><li><strong>R</strong> : <strong>R</strong>esetting : setting the latch to store a <strong><code>0</code></strong>;</li><li><strong>S</strong> : <strong>S</strong>etting: setting the latch to store a <strong><code>1</code></strong>;</li><li>The <strong>Quiescent</strong> (or <strong>quiet</strong>) State: the state when the latch is storing a value, either <code>0</code> or <code>1</code> and nothing is try to change the value.</li><li>When inputs <em><strong>S</strong></em> and <em><strong>R</strong></em> both have logic value <code>1</code>.</li><li>At this time, the output of <em><strong>a</strong></em> and <em><strong>b</strong></em> wonâ€™t change. (But <em><strong>a</strong></em> and <em><strong>b</strong></em> are the opposite if we set <em><strong>S</strong></em> and <em><strong>R</strong></em> properly.)</li><li><strong>Setting</strong> the Latch to <em><strong>a</strong></em> <code>1</code> or <em><strong>a</strong></em> <code>0</code></li><li>The latch can be set to <em><strong>a</strong></em> <code>1</code> by momentarily setting <em><strong>S</strong></em> to <code>0</code>.</li><li>The latch can be set to <em><strong>a</strong></em> <code>0</code> by momentarily setting <em><strong>R</strong></em> to <code>0</code>.</li><li>Both <em><strong>S</strong></em> and <em><strong>R</strong></em> must never be allowed to be set to <code>0</code> at the <strong>same time</strong>.</li></ul><h2 id="The-Gated-D-Latch"><a href="#The-Gated-D-Latch" class="headerlink" title="The Gated D Latch"></a>The Gated D Latch</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2014.png" alt="Untitled"></p><p>WE stands for write enable.When it is not asserted, the output S and R are both equal to 1. When it is momentarily set to 1,exactly one of the outputs(S or R) are set to 0,depending on the values of D.</p><p>D&#x3D;1â€”&gt;S&#x3D;0     D&#x3D;0â€”&gt;R&#x3D;0    WE&#x3D;0â€”&gt;S&#x3D;R&#x3D;1</p><h1 id="The-Concept-of-Memory"><a href="#The-Concept-of-Memory" class="headerlink" title="The Concept of Memory"></a>The Concept of Memory</h1><p>Memory is made up of a number of locations, each uniquely identifiable and each having the ability to store a value.We refer to the unique identifier associated with each memory location as its address. And the number of bits of information stored in each location as its addressability.</p><ul><li>Address Space : the total number of uniquely identifiable locations.</li><li>Addressability : æ³¨æ„å’Œ address space åšåŒºåˆ†ï¼Œaddress space æŒ‡çš„æ˜¯ memory ä¸­ï¼Œä¾æ®å¯»å€è¾“å…¥ï¼ˆä¸‹å›¾çš„<code>A[1:0]</code>ï¼‰èƒ½å¤ŸæŸ¥è¯¢åˆ°çš„ location æ•°é‡çš„<strong>ä¸Šé™</strong>ï¼ˆå³ä¸¤æ¡çº¿ä½†æ˜¯åªç”»å‡ºäº† 3ä¸ªlocationçš„è¯ï¼Œaddress space ä¾ç„¶æ˜¯ 4ï¼‰ã€‚</li><li>A 2^2-by-3-Bit Memory</li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2015.png" alt="Untitled"></p><p>â–ª å·¦ä¾§çš„ decoder è§£æ<code>A[1:0]</code>ä¸­ä¼ å…¥çš„ location ä¿¡æ¯ï¼Œç„¶åå°†è¯¥ä¿¡æ¯è¾“å…¥åˆ° mux ä¸­ï¼Œä»¥é€‰æ‹©è·¯ç”±å¯¹åº”çš„ location ä¿¡æ¯ã€‚</p><p>â–ª That is, the memory has an <strong>address space</strong> of four locations and an <strong>addressability</strong> of three bits. It requires two bits to specify the address.</p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2016.png" alt="Untitled"></p><h1 id="Sequential-Logic-Circuits"><a href="#Sequential-Logic-Circuits" class="headerlink" title="Sequential Logic Circuits"></a>Sequential Logic Circuits</h1><ul><li>Can both <strong>process</strong> information and <strong>store</strong> information.</li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2017.png" alt="Untitled"></p><ul><li>Sequential logic circuits are used to implement a very important class of mechanisms called <strong>finite state machines</strong>, which are used in essentially all branches of engineering.</li><li>e.g: used as controllers of electrical systems, mechanical systems, and aeronautical systems.</li></ul><h2 id="An-Example-The-Combination-Lock"><a href="#An-Example-The-Combination-Lock" class="headerlink" title="An Example: The Combination Lock"></a>An Example: The Combination Lock</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2018.png" alt="Untitled"></p><ul><li>Lock (a) will only open when you complete dialing in a specific order. Assume that the correct order is R13-L22-R3.</li><li>Lock (b) wonâ€™t care about how you complete rotation.</li></ul><h2 id="The-Concept-of-State"><a href="#The-Concept-of-State" class="headerlink" title="The Concept of State"></a>The Concept of State</h2><p>State: is a snapshot of all the relavent elements of the system at the moment the snapshot is taken.</p><ul><li>A finite state machine consists of five elements:</li></ul><ol><li>a finite number of states;</li><li>a finite number of external inputs ;</li><li>a finite number of external outputs;</li><li>an explicit specification of all state transitions;</li><li>an explicit specification of what determines each external output value;</li></ol><ul><li>There is no fixed amount of time between successive inputs to the finite stat machine above. We say these systems are <strong>asynchronous</strong> because there is nothing synchronizing when each state transition must occur.</li><li>Synchronous Finite State Machine: the state transitions take place, one after the other, at identical fixed units of time.</li></ul><p>Attention: Whether it is synchronous or not,they carry out work,one state transition at a time, moving closer to a goal.</p><ul><li>The Clock: Control of that synchronous behavior is in part the responsibility of the clock circuit. Each of the repeated sequence of identical intervals is referred to as a <strong>clock cycle.</strong></li></ul><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2019.png" alt="Untitled"></p><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2020.png" alt="Untitled"></p><h2 id="The-Flip-Flop"><a href="#The-Flip-Flop" class="headerlink" title="The Flip-Flop"></a>The Flip-Flop</h2><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2021.png" alt="Untitled"></p><p>â–ª The storage elements that allow us to read the current state throughout the current clock cycle, and <strong>not</strong> write the next state values into the storage elements <strong>until</strong> the beginning of the next clock cycle.</p><ul><li>Reading must be allowed throughout the clock cycle, and writing must occur at the end of the clock cycle.</li><li>The master &#x2F; slave flip-flop can be constructed out of <strong>two gated D latches</strong>, one referred to as the <strong>master</strong>, the other referred to as the <strong>slave</strong>.</li><li>Think about that: When <em>master</em> is â€œreadingâ€, the <em>slave</em> is â€œwritingâ€, and vice versa.</li><li>FF çš„è¡Œä¸ºåœ¨ä¸€ä¸ª Clock Cycle é‡Œå®Œæˆï¼Œåœ¨åˆ†æä¸åŒç»´åº¦çš„äº‹æƒ…çš„æ—¶å€™è¦ä»ä¸åŒç»´åº¦çš„è§’åº¦æ¥æ€è€ƒã€‚</li><li>æ›´åº•å±‚çš„ï¼š</li><li>å‡è®¾ Cycle çš„å‰åŠéƒ¨åˆ† Master å¯å†™ï¼Œ Slave åªè¯»ï¼Œåˆ™ï¼š</li><li>åœ¨æ¨¡å¼åˆ‡æ¢çš„é‚£ä¸€ç¬é—´ï¼ŒMaster å†™å…¥çš„æ•°æ®ä¼šè¢« Slave å­˜å‚¨ï¼›</li><li>æ›´æŠ½è±¡çš„ï¼š</li><li>åœ¨ Cycle å¼€å§‹ç»“æŸåï¼Œä¼šè¾“å‡º Cycle è¿›è¡Œæ—¶è¾“å‡ºçš„æ•°æ®ï¼›</li></ul><h1 id="The-Preview-of-Datapath-in-LC-3"><a href="#The-Preview-of-Datapath-in-LC-3" class="headerlink" title="The Preview of Datapath in LC-3"></a>The Preview of Datapath in LC-3</h1><p><img src="/Review%20Chap%203%20d0d116bbfd7a4a57bb62227c9d2c6bc8/Untitled%2022.png" alt="Untitled"></p><ul><li>The data path consists of all the logic structures that combine to process information in the core of the computer.</li><li>A <strong>register</strong> is simply a set of <em>n</em> flip-flops that collectively are used to store one <em>n</em> bit value.</li><li>In the figure, <strong>PC, IR, MAR,</strong> and <strong>MDR</strong> are all 16-bit <strong>registers</strong> that store 16 bits of information each. The block labeled <strong>REG</strong> <strong>FILE</strong> consists of <strong>eight registers</strong> that each store 16 bits of information.</li><li>The data path also shows three <strong>1-bit registers</strong>, <strong>N, Z,</strong> and <strong>P</strong>.</li></ul>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023 Review Chap 2</title>
      <link href="/2023/11/03/review-chap-2-44ab637553b3440d9a08155cb4dc336a/"/>
      <url>/2023/11/03/review-chap-2-44ab637553b3440d9a08155cb4dc336a/</url>
      
        <content type="html"><![CDATA[<h1 id="Review-Chap-2"><a href="#Review-Chap-2" class="headerlink" title="Review Chap 2"></a>Review Chap 2</h1><ul><li><p>Bits: We represent the presence of voltages as â€œ1â€ and the absence of a voltage as â€œ0â€. We refer to each 0 and each 1 as a â€œbitâ€, which is shortened from binary digit.</p></li><li><p>Precisely, the electronic circuits in the computer differentiate voltages close to 0 from voltages far from 0.</p></li><li><p>With <em>k</em> bits, we can distinguish 2^k distinct items at most.</p></li><li><p>Data Types: 1. 2â€™s complement integers for representing positive and negative integers that we wish to perform arithmetic on, 2. ASCII codes for representing characters that we wish to input to a computer via the keyboard or output from the computer via a monitor(These are two data types which will be used in following chapters)</p></li><li><p>Integer data types</p><ol><li>Unsigned Integers.ï¼ˆæˆ‘å¯»æ€ç€è¿™ç©æ„æˆ‘è¿˜æ˜¯ä¼šçš„ï¼‰with k bits,we can represent 2^k integers,ranging from 0 to 2^k -1.</li><li>Signed Integers. ï¼ˆç”¨ä¸­æ–‡ï¼‰æ­£æ•°ä»¥0ä¸ºå…ˆå¯¼ï¼Œè´Ÿæ•°ä»¥1ä¸ºå…ˆå¯¼ï¼Œwith k bits,we can represent 2^k -1 integers,ranging from - 2^ï¼ˆk -1ï¼‰-1 to 2^ï¼ˆk -1ï¼‰-1. ä½†æ˜¯å‡ºç°äº†-0ï¼ˆå¦‚åœ¨äº”ä½å½“ä¸­ï¼Œ10000è¡¨ç¤º-0è€Œ00000è¡¨ç¤º0ï¼Œè¿™å°±å°´å°¬äº†ï¼‰</li><li>1â€™s complement integersï¼ˆåç ï¼Œä¼¼ä¹ä¸é‡è¦ï¼‰</li><li>2â€™s complement integers ï¼ˆè¡¥ç ï¼Œå¾ˆé‡è¦ï¼Œä¸€ä¼šå±•å¼€è®²ï¼‰</li></ol><p>  <img src="/Review%20Chap%202%2044ab637553b3440d9a08155cb4dc336a/Untitled.png" alt="Untitled">  </p></li><li><p>å…³äºè¡¥ç çš„å¼•å…¥ï¼Œä¹¦ä¸­ä»åº•å±‚å®ç°çš„è§’åº¦ç»™å‡ºäº†è§£é‡Šï¼Œè¿›è¡Œå½’çº³çš„è¯æˆ‘è®¤ä¸ºä¸»è¦æ˜¯è¿™ä¸¤ä¸ªå› ç´ ï¼šâ‘  2â€™s complement ä¸­â€œæº¢å‡ºâ€ä¸â€œå–æ¨¡â€çš„å…³ç³»ï¼›â‘¡ ALU æ¨¡å—åªè¿›è¡ŒåŠ æ³•è¿ç®—ï¼Œè€Œä¸èƒ½è¿›è¡Œå‡æ³•è¿ç®—ï¼›ï¼ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ‰€è°“çš„ç¬¦å·ä½æ˜¯ç»™äººçœ‹çš„ï¼Œæˆ–è€…è¯´åªæ˜¯ä¸€ä¸ªç‰¹å¾ã€‚åœ¨å®é™…è¿‡ç¨‹ä¸­å¹¶ä¸å­˜åœ¨â€œç¬¦å·ä½â€ï¼Œå³è¯¥ä½ä¹Ÿå‚ä¸åŠ æ³•è®¡ç®—ï¼‰</p></li></ul><aside>ğŸ’¡ ALU : arithmetic and logic unit, which is very important in future study.</aside><p>æˆ‘è§‰å¾—äºŒè¿›åˆ¶åŠ æ³•æˆ‘è¿˜ä¸è‡³äºä¸ä¼šï¼Œè¿™é‡Œçœäº†ã€‚</p><ul><li><p>Conversion  Binary to Decimal</p><ol><li>examine the leading bit b7 to determine whether it is positive or negative.If it is negative, do step 2 after flipping all the bits and adding 1.</li><li>then simply: b6 *2^6+b5 *2^5+â€¦+b0 *2^0</li><li>get the result, then if it is negative, donâ€™t forget the minus sign.</li></ol></li><li><p>Conversion Decimal to Binary</p><ol><li>obtain the binary representation of the magnitude of N by forming the equation N&#x3D;b6â‹…2^6+b5â‹…2^5+â€¦+b0â‹…2^0.  and repeating and following,until the left side of the equation is 0: a.If N is odd,the rightmost bit is 1.If N is even,the rightmost bit is 0.<br>  b.Subtract 1 or 0(according to whether N is odd or even)from N,remove<br>  the least signiï¬cant term from the right side,and divide both side sof<br>  the equation by 2.</li><li>if it is positive, add a leading 0 then finished.</li><li>if it is negative, add a leading 0 and then form the negative of this 2â€™s complement representation, and then you are done.</li></ol></li><li><p>Specially for floating point data type</p><ul><li>1 bit for the sign (positive or negative)</li><li>8 bits for the range (the exponent field)</li><li>23 bits for precision (the fraction field)  æ•°æ®éƒ¨åˆ†ï¼Œä½†æ˜¯ç»„ç»‡å½¢å¼æœ‰ä¸€äº›å¾®å¦™ï¼Œâ€œç¬¬ä¸€ä½â€æ˜¯<code>0</code>è¿˜æ˜¯<code>1</code>æœ‰ç‰¹æ®Šçš„å¤„ç†æ–¹å¼</li></ul><p>  <img src="/Review%20Chap%202%2044ab637553b3440d9a08155cb4dc336a/Untitled%201.png" alt="Untitled"></p>  <aside>  ğŸ’¡ The 32-bit floating point data type    </aside>  <ul><li><p>They are mostly in normalized form: (ä¸éœ€è¦è€ƒè™‘è¡¥ç ï¼‰</p><p>  <img src="https://cdn.nlark.com/yuque/__latex/037c64c8fbf18f1fa3486b7f549ebb4b.svg" alt="https://cdn.nlark.com/yuque/__latex/037c64c8fbf18f1fa3486b7f549ebb4b.svg"></p></li></ul></li><li><p>exponent&#x3D;00000000â€”â€”subnormal numbers</p></li><li><p>exponent&#x3D;11111111â€”â€”infinity</p></li><li><p>Sign-extension (<strong>SEXT</strong>)</p></li><li><p>The value of a <strong>positive number</strong> does <strong>not change</strong> if we <strong>extend</strong> the sign bit <strong>0</strong> as many bit positions <strong>to the left</strong> as desired. Similarly, the value of a <strong>negative number</strong> does <strong>not change</strong> by <strong>extending</strong> the sign bit <strong>1</strong> as many bit positions <strong>to the left</strong> as desired.</p></li><li><p>ä¹Ÿå°±æ˜¯è¯´æŒ‰ç…§ç¬¦å·ä½å‘é«˜ä½æ‰©å±•ï¼Œä¸”è¿™ç§æ‰©å±•æ˜¯ä¸ä¼šå½±å“åŸæ¥çš„å€¼çš„ã€‚</p></li><li><p>Overflow</p></li><li><p>æœ€é«˜ä½ï¼ˆæ¯”å¦‚ç¬¦å·ä½ï¼‰è¿›ä½åä¸ä¼šåˆ›å»ºä¸€ä¸ªæ›´é«˜ä½æ¥å­˜å‚¨è¿™ä¸ªè¿›ä½ä¿¡æ¯ï¼Œè€Œæ˜¯ç›´æ¥ä¸¢å¼ƒè¿™ä¸ªè¿›ä½ï¼Œä¹Ÿå°±æ˜¯â€œæº¢å‡ºâ€ï¼Œåœ¨æ•°å­¦å±‚é¢æ¥çœ‹ï¼Œå°±ç±»ä¼¼äºå–æ¨¡ï¼Œæ¯”å¦‚ï¼Œå¯¹åº”<code>1110</code> + <code>1001</code> &#x3D; <code>~~1~~0111</code>ã€‚</p><p>  <img src="https://cdn.nlark.com/yuque/__latex/5b8307da33e4ddcbecd7ca8925c4aaca.svg" alt="https://cdn.nlark.com/yuque/__latex/5b8307da33e4ddcbecd7ca8925c4aaca.svg"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS 2023</title>
      <link href="/2023/11/02/ics-2023-88cec008ce4942edba428dc0868292e0/"/>
      <url>/2023/11/02/ics-2023-88cec008ce4942edba428dc0868292e0/</url>
      
        <content type="html"><![CDATA[<h1 id="ICS-2023"><a href="#ICS-2023" class="headerlink" title="ICS 2023"></a>ICS 2023</h1><p>2023å¹´7æœˆ12æ—¥-28æ—¥ æˆè¯¾è€å¸ˆï¼šYale Patt Jxh<br>Pattä¸Šè¯¾è¿˜æ˜¯å¾ˆå€¼å¾—ä¸€å¬çš„ï¼ˆå‰ææ˜¯ä½ è·Ÿå¾—ä¸Šï¼‰ï¼Œjxhå°±æ¯”è¾ƒä¸€è¨€éš¾å°½ï¼Œ2023å¹´è²Œä¼¼æ˜¯pattæœ€åä¸€å¹´æ¥ä¸­å›½äº†ï¼Œä»¥åè¿™è¯¾æœ‰æ²¡æœ‰è¿˜ä¸¤è¯´ã€‚<br>è¿™ä»½ç¬”è®°æ˜¯æˆ‘æš‘å‡å›äº†å¾·å·åœ¨å›¾ä¹¦é¦†è¡¥å¤©çš„ä½œå“ï¼Œå€Ÿé‰´äº†å¾ˆå¤šåˆ«äººçš„æ™ºæ…§ç»“æ™¶ï¼Œæ‰€ä»¥æˆ‘è¿˜æ˜¯é‚£ä¸ªèœé¸¡ç½¢äº†ã€‚<br>å„ä½å‡‘åˆçœ‹å§ã€‚</p>]]></content>
      
      
      <categories>
          
          <category> è¯¾ç¨‹ç¬”è®° </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ICS </tag>
            
            <tag> è®¡ç®—æœºç³»ç»Ÿæ¦‚è®º </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>æ¦œä¸Šç•™åä¹‹å</title>
      <link href="/2023/10/15/after-successful/"/>
      <url>/2023/10/15/after-successful/</url>
      
        <content type="html"><![CDATA[<h1 id="A-blog-written-in-2023-10"><a href="#A-blog-written-in-2023-10" class="headerlink" title="A blog written in 2023.10"></a>A blog written in 2023.10</h1><p>æ­£åœ¨ç–¯ç‹‚æ†‹OOPçš„ä»£ç ï¼Œçªç„¶è€³æœºå½“ä¸­çš„æ­Œåˆä¸€æ¬¡åˆ‡åˆ°äº†Wherever You Will Goï¼ŒThe Callingä¹é˜Ÿçš„æ­Œã€‚  </p><p>æˆ‘å–œæ¬¢The Callingå’Œå®ƒçš„ä¸»å”±Alex Bandçš„å‡ ä¹æ‰€æœ‰æ­Œæ›²ï¼Œè¿™é¦–æ­Œæˆ‘æ›´æ˜¯åœ¨ç¤¾äº¤å¹³å°åˆ†äº«è¿‡ä¸æ­¢ä¸€æ¬¡ã€‚ä½†æœ€è¿‘å‡ æ¬¡å¬è¿™é¦–æ­Œï¼Œæˆ‘å´æœ‰äº†ä¸€äº›æ¸¸ç¦»äºæ­Œè¯ä¹‹å¤–çš„æ„Ÿå—ï¼Œè€ƒè™‘åˆ°OOPçš„ddlè¿˜æ—©ï¼Œæˆ‘å†³å®šå…ˆæŠŠå®ƒæç½®ä¸€è¾¹ï¼Œå¼€å§‹å†™ç‚¹ä¸ä¸€æ ·çš„ä¸œè¥¿ã€‚  </p><p>è¿™æ˜¯ä¸€é¦–ä»€ä¹ˆæ­Œï¼Ÿè¿™æ˜¯ä¸€é¦–è™½ç„¶åœ¨å›½å†…çƒ­åº¦ä¸€èˆ¬ï¼Œä½†æ˜¯å´åœ¨YouTubeå’ŒSpotifyæ”¶è·ä¸Šäº¿å¬ä¼—çš„æ­Œæ›²ï¼›è¿™æ˜¯ä¸€é¦–æŠŠä¸€ä¸ªæœ¬æ¥é»˜é»˜æ— é—»çš„æ™®é€šä¹é˜Ÿä¸€ä¸‹å­æ¨ä¸Šé¡¶æµçš„æ­Œæ›²ï¼›è¿™ä¹Ÿæ˜¯ä¸€é¦–èƒ½æ‰“åŠ¨äººå¿ƒå¼•èµ·å…±é¸£çš„æ­Œæ›²ï¼ŒOriginally Performed by The Calling.  </p><p>ä½†æ˜¯ï¼Œå¯æ‚²çš„æ˜¯ï¼Œå¦‚ä»Šçš„The Callingå’ŒAlex Bandï¼Œåªå‰©ä¸‹è¿™ä¹ˆä¸€é¦–èƒ½è¢«äººè®°ä½çš„æ­Œæ›²äº†ï¼Œä¸€é¦–Alexåœ¨16å²æ—¶å°±å†™å‡ºæ¥ï¼Œ20å²å‘è¡Œçš„æ­Œæ›²ï¼Œè€Œå¦‚ä»Šï¼Œ20å¤šå¹´è¿‡å»äº†ï¼Œä»–ä»¬å´åªå‰©ä¸‹è¿™ä¹ˆä¸€é¦–å‹‰å¼ºç®—å¾—ä¸Šæµè¡Œçš„æ­Œæ›²ï¼Œå®Œç¾è¯ é‡ŠOne hit wonderã€‚  </p><p>è¿™æ€ªAlexå’Œä»–å½“æ—¶çš„å›¢é˜Ÿå—ï¼Ÿæˆ‘è§‰å¾—æ˜¾ç„¶ä¸æ˜¯ï¼Œæ— æ•°çš„æ¬§ç¾æ­Œæ‰‹éƒ½é¢ä¸´è¿‡è¿™ç§é—®é¢˜ï¼Œone hit wonder ç”šè‡³ two hit wonderï¼Œå³æ‰€è°“â€æ˜™èŠ±ä¸€ç°â€œï¼Œä¾‹å¦‚ï¼ŒDaniel Powteråªæœ‰Bad Dayå’ŒFree Loopä¸¤é¦–æ‹¿å¾—å‡ºæ‰‹çš„æ­Œæ›²ï¼Œ3 Doors Down åªæœ‰ä¸€é¦–ã€ŠHere Without Youã€‹èƒ½å¤Ÿè¢«äººè®°ä½ï¼ŒJames Bluntå”±äº†è¿™ä¹ˆå¤šå¹´æ­Œï¼Œä¹Ÿåªæœ‰ä¸€é¦–ã€ŠYouâ€™re Beautifulã€‹å¤§çº¢å¤§ç´«ï¼Œè¿™ä¸ªé—®é¢˜ç”šè‡³è®©ä»–åœ¨æ—¥åæ¨å‡ºçš„ä¸€é¦–ã€Š2005ã€‹ä¸“é—¨åæ§½â€œåªç«ä¸€é¦–æ­Œâ€å¸¦ç»™ä»–çš„ä¸æ»¡â€¦â€¦      </p><p>ä¹Ÿæ˜¯ï¼Œä¸æ˜¯äººäººéƒ½æ˜¯å‘¨æ°ä¼¦ï¼ŒTaylor Swiftæˆ–è€…Ed Sheeranã€‚â€œåªç«ä¸€é¦–æ­Œâ€æ€»æ¯”ä»€ä¹ˆæˆå°±éƒ½æ²¡æœ‰å¼ºï¼Œè€Œå¼ºä¸­æœ€å¼ºæ˜¯å¾ˆéš¾è¾¾åˆ°çš„ï¼Œæœ‰äº›æ—¶å€™ï¼Œå‡ºåæˆåŠŸè¿‡é‚£ä¹ˆä¸€æ¬¡ï¼Œå°±è¶³å¤Ÿæ™®é€šäººDreaming in Redäº†ã€‚  </p><p>äºæ˜¯åˆæƒ³åˆ°æˆ‘è‡ªå·±ã€‚  </p><p>æˆ‘æœ¬æ¥å°±æ˜¯ä¸€ä¸ªä¸å¯¹è‡ªå·±æœ‰è¿‡é«˜è¦æ±‚çš„äººï¼Œä¹Ÿæ˜¯æŠŠæ¡ä½äº†ä¸€æ¬¡é‡è¦çš„æœºä¼šï¼ˆé«˜è€ƒï¼‰ï¼Œåˆ°è¾¾äº†ç›®å‰æˆ‘æ‰€åœ¨çš„ä½ç½®ï¼Œä½†æ˜¯åœ¨è¿™ä¸ªç¯å¢ƒé‡Œé¢æˆ‘åˆè¶Šå‘æ„Ÿè§‰åˆ°è‡ªå·±çš„å¹³å‡¡ï¼Œä¸å…¶ä»–äººçš„å·®è·ä¹‹å¤§ï¼Œæˆ‘å¤§æ¦‚çŸ¥é“æˆ‘å¾ˆéš¾æˆä¸ºå‘¨æ°ä¼¦ä¹‹ç±»çš„å¸¸é’æ ‘äº†ï¼Œä¸è¿‡ï¼Œæˆ‘ä¹Ÿä¸å¤ªæƒ³æˆä¸ºAlexã€‚  </p><p>ä¹‹å‰ç¿»çœ‹inså’Œæ¨ç‰¹ï¼Œå‘ç°Alex Bandç°åœ¨æ— è®ºæ˜¯é¢œå€¼è¿˜æ˜¯å”±åŠŸéƒ½å¤§ä¸å¦‚å‰ï¼Œä¹‹å‰é‚£ä»½ä¿Šæœ—çš„é¢å®¹å’Œç‹¬ä¸€æ— äºŒçš„æµ“é‡å—“éŸ³å˜æˆäº†æ†”æ‚´æ¯æ§çš„å½¢å®¹å’Œææ˜“ç ´éŸ³çš„å—“å­ã€‚å°½ç®¡å¦‚æ­¤ï¼Œä»–çš„ä¸»é¡µä¸Šä¾ç„¶ç”¨é†’ç›®çš„å­—ä½“å‘Šè¯‰æ‰€æœ‰äººï¼šä»–æ˜¯Wherever You Will Goçš„åŸå”±ã€‚ä»–åœ¨16å²çš„çµå…‰ä¸€ç°ï¼Œæˆä¸ºäº†ä»–æ•´ä¸ªäººç”Ÿä¸­çš„æœ€å¤§é—ªå…‰ç‚¹ã€‚  </p><p>é‚£ä¹ˆï¼Œæˆ‘18å²æ—¶å€™çš„çµå…‰ä¸€ç°ï¼Œä¼šæˆä¸ºæˆ‘ä»¥åäººç”Ÿä¸­æœ€å€¼å¾—ä¸€æçš„ä¸œè¥¿å—ï¼Ÿ  </p><p>æˆ‘ä¸å¸Œæœ›å¦‚æ­¤ï¼Œæœªæ¥å¦‚ä½•ï¼Œæˆ‘æ‹­ç›®ä»¥å¾…ã€‚  </p><p>10.15å†™äºç´«é‡‘æ¸¯åŸºå›¾ä¸€æ¥¼  </p>]]></content>
      
      
      <categories>
          
          <category> éšç¬” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> å¤§å­¦ç”Ÿæ´» </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>å¤§å­¦ç¬¬ä¸€å¹´å¯¹è‡ªå·±çš„ä¸€äº›æ€»ç»“ï¼ˆ2023.07ï¼‰</title>
      <link href="/2023/07/02/first-year-summary/"/>
      <url>/2023/07/02/first-year-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="å¤§å­¦ç¬¬ä¸€å¹´å¯¹è‡ªå·±çš„ä¸€äº›æ€»ç»“ï¼ˆ2023-07ï¼‰"><a href="#å¤§å­¦ç¬¬ä¸€å¹´å¯¹è‡ªå·±çš„ä¸€äº›æ€»ç»“ï¼ˆ2023-07ï¼‰" class="headerlink" title="å¤§å­¦ç¬¬ä¸€å¹´å¯¹è‡ªå·±çš„ä¸€äº›æ€»ç»“ï¼ˆ2023.07ï¼‰"></a>å¤§å­¦ç¬¬ä¸€å¹´å¯¹è‡ªå·±çš„ä¸€äº›æ€»ç»“ï¼ˆ2023.07ï¼‰</h1><p>å¤§å­¦çš„ç¬¬ä¸€ä¸ªå­¦å¹´ï¼Œéšç€ä»Šå¤©ä¸‹åˆæœ€åä¸€é—¨è¯¾çš„å‡ºåˆ†è€Œå®£å‘Šç»“æŸã€‚è™½ç„¶æˆ‘æš‘å‡è¿˜æœ‰ä¸€é—¨çŸ­å­¦æœŸè¯¾è¦ä¸Šåˆ°ä¸ƒæœˆåº•ï¼Œä¸è¿‡é‚£å·²ç»å±äºæ˜¯ä¸‹ä¸ªå­¦å¹´çš„è¯¾äº†ã€‚<br>æ‰€ä»¥è¯´æˆ‘å°±æœ‰æ—¶é—´æ€è€ƒä¸€ä¸‹å¤§ä¸€è¿™ä¸€å¹´ï¼Œæˆ‘å¹²äº†ä»€ä¹ˆï¼Œæ”¶è·äº†ä»€ä¹ˆï¼Œå¤±å»äº†ä»€ä¹ˆã€‚<br>æˆ‘è®°å¾—æˆ‘ç¬¬ä¸€å¤©æ¥åˆ°æ±‚æ˜¯å›­çš„åœºæ™¯ï¼Œä»ä¸œäºŒé—¨è¿›å»ï¼Œè·Ÿæˆ‘çˆ¸å’Œæˆ‘å“¥è¯´å†è§ï¼Œæ‹–ç€è¡Œæä¸Šäº†æ¥é©³è½¦ï¼Œä¸‹è½¦ï¼Œèµ°è¿›å®¿èˆï¼Œæ•´ä¸ªçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘å…¨ç¨‹æ³¨è§†ç€çª—å¤–æˆ–è€…çœ‹ç€å››å‘¨ï¼Œçœ‹ç€è¿™ä¸ªæˆ‘é«˜ä¸­ä¸‰å¹´ä»æ¥æ²¡æœ‰æƒ³è¿‡èƒ½å¤Ÿè€ƒä¸Šçš„å­¦æ ¡ã€‚<br>ç„¶åæˆ‘è¿›äº†å¯å®¤ï¼Œæé’¥åŒ™ï¼Œå¼€å¯å®¤é—¨ï¼Œå½“æ°´æ³¥åœ°é¢å’Œç®€é™‹çš„ä¸Šä¸‹é“ºæ˜ å…¥çœ¼å¸˜ä¹‹æ—¶ï¼Œæˆ‘è„±å£è€Œå‡ºçš„æ˜¯â€œæ“â€ã€‚<br>åˆç€æˆ‘è¿›äº†æµ™å¤§è¯´çš„ç¬¬ä¸€ä¸ªå­—æ˜¯ä¸ªè„å­—ã€‚<br>ä¸è¿‡å¾ˆå¿«æˆ‘å°±æ¥å—äº†ä½å®¿æ¡ä»¶ï¼Œå’Œèˆå‹ç†Ÿç»œï¼Œè®¤è¯†æ–°çš„ç­é›†ä½“ï¼Œç„¶åæ˜¯å†›è®­ã€‚<br>å†›è®­çš„è¿‡ç¨‹æˆ‘å°±ä¸ç»†è¯´äº†ï¼Œæˆ‘çš„è®°å¿†ä¹Ÿæ¯”è¾ƒæ¨¡ç³Šï¼Œåªè®°å¾—æœ€åæ‹¿äº†ä¸ª3.9ï¼Œæ­£å½“æˆ‘è§‰å¾—è¿˜è¡Œçš„æ—¶å€™ï¼Œä¸€åˆ·æœµæœµï¼Œå‘ç°è¿˜æœ‰äººæ­£å› ä¸ºå†›è®­æ²¡æ»¡ç»©è€Œé—·é—·ä¸ä¹ï¼Œæˆ‘ç¬é—´å°±ä¸æ·¡å®šäº†ã€‚<br>æˆ‘å¼€å§‹ç¬¬ä¸€æ³¢åˆæ­¥ç„¦è™‘ï¼Œçœ‹ç€å‘¨å›´çš„äººä¸ªä¸ªéƒ½åƒå·ç‹ï¼›ä¸è¿‡å¾ˆå¿«å°±åœæ­¢äº†ï¼šæˆ‘å‘ç°è‡³å°‘åœ¨å¾®ç§¯åˆ†è¿™ä¸€é—¨è¯¾ä¸Šï¼Œæ¯”æˆ‘èœçš„äººè¿˜æ˜¯å¤§æœ‰äººåœ¨çš„ï¼Œæˆ‘å¤§å¯ä¸å¿…è¿™ä¹ˆå‘å¾®ï¼Œè¿™ä¹ˆç„¦è™‘ã€‚å­¦å¥½äº†ï¼Œé‚£å°±å¥½ï¼›å­¦å·®äº†ï¼Œæˆ‘ä¹Ÿä¸æ˜¯æœ€å·®ï¼›å°±ç®—æˆ‘æ˜¯æœ€å·®çš„é‚£ä¸ªï¼Œé‚£ä¹Ÿåªèƒ½è¯´æ˜æˆ‘æœ‰å……è¶³çš„ä¸Šå‡ç©ºé—´ã€‚å†è¯´äº†ï¼Œå½“å€’æ•°å‡ åå¯¹æˆ‘åˆä¸æ˜¯æ–°é²œäº‹ï¼Œé«˜ä¸­æˆ‘ä¹Ÿä¸æ˜¯æ²¡å½“è¿‡ã€‚<br>ä¸Šå­¦æœŸçš„ç”Ÿæ´»ç»†èŠ‚æ—©å°±è®°ä¸æ¸…äº†ï¼Œå°±è®°å¾—ä¸€äº›è®°å¿†ç¢ç‰‡ï¼šæ¯”å¦‚ä¸œä¸‰çš„æ ¸é…¸æ£€æµ‹ï¼Œæ¯”å¦‚çº¿æ€§ä»£æ•°æœŸä¸­ä¸åŠæ ¼ï¼Œæ¯”å¦‚åœ¨åŒ—æ•™å’Œè¶³åçš„åŒå¿—ä»¬çœ‹ä¸–ç•Œæ¯ï¼Œæ¯”å¦‚è¢«æ‹‰å»æ¡åºéš”ç¦»ï¼Œç­‰ç­‰ã€‚ç„¶ååœ¨12æœˆ10å·çš„å››çº§è€ƒè¯•ä»¥åï¼Œæˆ‘è¿…é€Ÿæ¶¦å›å¾·å·ã€‚<br>è€ƒè¯•å»¶åï¼Œå¯’å‡æˆ‘ä¸è¯´æ˜¯å·äº†ï¼Œè‡³å°‘ä¹Ÿèƒ½è¯´æ˜¯è®¤çœŸå­¦äº†ï¼Œå¤§ä¸€ä¸Šå­¦æœŸçš„GPAå¥½æ­¹æœ‰ä¸ª4.2å§ã€‚<br>åˆ°äº†å¤§ä¸€ä¸‹ï¼Œæˆ‘è¸Œèº‡æ»¡å¿—çˆ†é€‰30+å­¦åˆ†ï¼Œé€‰çš„è¯¾ä¹Ÿæœ‰å¤§è‹±äº”è¿™æ ·å¬åå°±è®©äººé—»é£ä¸§èƒ†çš„è¯¾ã€‚ç„¶åå°±åœ¨æˆ‘ä»¥ä¸ºä¸€åˆ‡å°½åœ¨æŒæ¡ä¹‹ä¸­çš„æ—¶å€™ï¼Œä¸€åˆ‡å°±ä¸å‡ºæ„å¤–åœ°å‡ºæ„å¤–äº†ã€‚<br>ä¸€é—¨ç¨‹åºè®¾è®¡è¯¾ï¼Œé˜Ÿå‹ä¸ç»™åŠ›ï¼ŒåŸæœ¬ç¡®å®šçš„é€‰é¢˜ä»»åŠ¡æœªèƒ½åœ¨è§„å®šæ—¶é—´å†…å®Œæˆï¼Œæˆ‘åå€’æ˜¯åœ¨è§„å®šæ—¶é—´å†…ç²¾ç¥çŠ¶æ€å´©æºƒï¼Œä¸Šè¯¾ä¹Ÿä¸å»ä¸Šï¼Œä½œä¸šä¹Ÿå†™ä¸åŠ¨ï¼Œç”šè‡³éƒ½æƒ³é‡å¼€äº†ï¼Œåœ¨ä¸€å‘¨å¤šçš„æ—¶é—´é‡Œï¼Œæˆ‘ä¸ä»…ä¸€è¡Œä»£ç éƒ½æ•²ä¸åŠ¨ï¼Œå…¶ä»–è¯¾ä¹Ÿå­¦ä¸è¿›å»ï¼Œè¿™å°±è®©æˆ‘æœ¬å°±è–„å¼±çš„åŸºç¡€è¯¾é›ªä¸ŠåŠ éœœã€‚<br>è¿™å°±æ˜¯æˆ‘ç¬¬äºŒæ³¢ç„¦è™‘å¼€å§‹çš„æ—¶å€™ï¼šçœ‹ç€æˆ‘è®¤è¯†çš„äººä¸€ä¸ªä¸ªæˆç»©çªé£çŒ›è¿›å¾—å¿ƒåº”æ‰‹ï¼Œç”šè‡³æœ‰æ—¶é—´æèµ·äº†ACMç§ç§ï¼Œæˆ‘å´è¢«ä¸€ä¸ªç®€å•çš„ç¨‹åºè®¾è®¡è¯¾å›°ä½åŠ¨å¼¹ä¸å¾—ï¼Œç”šè‡³æ¿’ä¸´æŒ‚ç§‘ï¼Œæˆ‘å¯¹è‡ªå·±çš„æ€€ç–‘å’Œå‘å¾®æ„Ÿåˆä¸Šå‡äº†ä¸€ä¸ªæ¡£æ¬¡ï¼Œçœ‹ç€å­¦é™¢å‘çš„é™¢è¡«ï¼Œæˆ‘ä¸€åº¦æ€€ç–‘æˆ‘é…ä¸é…æŠŠå®ƒç©¿åœ¨èº«ä¸Šã€‚<br>è€ƒè¯•å‘¨ç»“æŸï¼Œæˆ‘çœ‹ç€æˆ‘çš„GPAæ…¢æ…¢ä¸‹é™ï¼Œæœ€åç¨³å®šåœ¨ä¸€ä¸ªä½çš„ä¸èƒ½å†ä½çš„æ•°å­—ï¼Œæˆ‘çªç„¶é‡Šæ€€äº†ã€‚<br>å¤§å­¦ç”Ÿæ´»åˆä¸æ˜¯åªæœ‰GPAï¼Œæˆ‘å¤§å¯ä»¥åœ¨åˆ«çš„åœ°æ–¹è¯æ˜è‡ªå·±é…å¾—ä¸Šå½“æµ™å¤§äººï¼Œé…å¾—ä¸Šè®¡é™¢ã€‚å­¦ä¹ ä¸æ˜¯ä¸€åˆ‡ï¼Œç¤¾å›¢æ´»åŠ¨ã€ä½“è‚²é”»ç‚¼ã€æ„Ÿæƒ…ç”Ÿæ´»ï¼Œæ¯ä¸€ä¸ªéƒ½å¯ä»¥è¿‡å¾—å¾ˆå……å®ï¼Œéƒ½å¯ä»¥ä¸°å¯Œç”Ÿæ´»ã€‚<br>æ‰€ä»¥è¯´ï¼Œå¤§å­¦ä¸€å¹´ï¼Œæˆ‘æ”¶è·äº†ä»€ä¹ˆï¼Ÿ<br>æˆ‘æ”¶è·äº†çŸ¥è¯†ï¼Œæ¯«æ— ç–‘é—®ï¼Œè™½ç„¶æŒæ¡ç¨‹åº¦å’Œå…¶ä»–äººäº¦æœ‰å·®è·ï¼›æ”¶è·äº†æœ‹å‹ï¼Œå¾ˆå¤šæœ‹å‹ï¼›æ”¶è·äº†ç»éªŒï¼Œæ— è®ºæ˜¯è½¬æ’­è¶³çƒæ¯”èµ›çš„ç»éªŒè¿˜æ˜¯ä¸€ä¸ªäººä¸‰å¤©soloä¸€ä¸ªå¤§ç¨‹åº+å®éªŒæŠ¥å‘Šçš„ç»éªŒï¼Œéƒ½æ˜¯å¥½çš„ã€‚<br>å”¯ä¸€ç¾ä¸­ä¸è¶³çš„æ˜¯æ²¡æœ‰æ”¶è·çˆ±æƒ…ï¼ˆbushiï¼‰ã€‚<br>æˆ‘æ¥ä¸‹æ¥è¦å¹²ä»€ä¹ˆï¼Ÿ<br>GPAä¸æ˜¯å…¨éƒ¨ï¼Œæˆ‘åªæƒ³å¥½å¥½è¿‡å®Œå¤§å­¦åé¢ä¸‰å¹´ï¼Œåº•çº¿æ˜¯å­¦åˆ°ä¸œè¥¿å¹¶ä¸”ä¸æŒ‚ç§‘ï¼Œä¸Šé™é‚£æˆ‘ä¹Ÿä¸çŸ¥é“ã€‚<br>æ€ä¹ˆå½¢å®¹æˆ‘ç†æƒ³ä¸­çš„å¤§å­¦ç”Ÿæ´»ï¼Ÿå¿«ä¹ï¼Ÿä¸å‡†ç¡®ï¼Œå……å®ï¼Ÿä¹Ÿä¸å‡†ç¡®ã€‚åå€’æ˜¯æˆ‘é‚£ä¸ªå……æ»¡äº†æˆè°‘è‰²å½©çš„å¾®ä¿¡æ˜µç§°èƒ½å½¢å®¹æˆ‘çš„é¢„æƒ³ï¼šå‡†æ—¶ä¸æ—©é€€ã€‚<br>å‡†æ—¶åˆ°è¾¾å¤§å­¦ç”Ÿæ´»çš„æ¯ä¸€ä¸ªé‡è¦èŠ‚ç‚¹ï¼Œä¸è‰è‰é€€åœºï¼Œä¸å´©æºƒæ–­çº¿ï¼Œå¤Ÿäº†ï¼Œæˆ‘åªæ±‚å‡†æ—¶ä¸æ—©é€€ã€‚<br>Eddie<br>7æœˆ3æ—¥æ™šå†™äºæµ™æ±Ÿå¤§å­¦ç´«é‡‘æ¸¯æ ¡åŒºç¢§å³°</p>]]></content>
      
      
      <categories>
          
          <category> éšç¬” </category>
          
      </categories>
      
      
        <tags>
            
            <tag> å¤§å­¦ç”Ÿæ´» </tag>
            
            <tag> æ€»ç»“ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>æ¬¢è¿é¡µ</title>
      <link href="/2023/01/01/first-blog/"/>
      <url>/2023/01/01/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="First-Time-Using-Hexo"><a href="#First-Time-Using-Hexo" class="headerlink" title="First Time Using Hexo"></a>First Time Using Hexo</h1><p>Itâ€™s a good thing to put something here.<br>äº†è§£æˆ‘çš„äººå¤§æ¦‚çŸ¥é“æˆ‘æ˜¯æœ‰ä¸€å®šçš„è¡¨è¾¾æ¬²æœ›çš„ï¼Œæ‰€ä»¥ä¸ªäººç½‘ç«™ç»™äº†æˆ‘ä¸€ä¸ªå¾ˆå¥½çš„æœºä¼šå»å¤šå•°å—¦ä¸¤å¥ï¼Œniceã€‚<br>è¿™æ˜¯å¦ä¸€ä¸ªæ¬¢è¿é¡µï¼Œæ¬¢è¿ä½ ä»¬éšæ—¶æ¥çœ‹çœ‹æˆ‘èƒ½æå‡ºç‚¹ä»€ä¹ˆåå ‚ï¼Œä¸è¿‡ä¸è¦å¯¹æˆ‘æœ‰éå¸¸å¤§çš„æœŸæœ›ã€‚</p>]]></content>
      
      
      
        <tags>
            
            <tag> Welcome </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
